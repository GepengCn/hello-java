# 动态规划

![](https://p.ipic.vip/utwjtb.jpg)

## 原理

- 将递归算法重写成非递归算法，让后者把那些子问题的答案系统地记录起来
- 递归会造成冗余计算，已解过的子问题无法再利用


## 与分治算法比较

!!! tip "与分治算法比较"

    - [x] 分治算法

    将问题划分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来，求出原问题的解。

    - [x] 动态规划

    应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。

    - [x] 子问题重叠
        - 在这种情况下，分治算法会做许多不必要的工作，它会反复地求解那些公共子子问题。
        - 动态规划对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算。

## 设计动态规划算法步骤

1. 刻画一个最优解的结构特征
2. 递归地定义最优解的值。
3. 计算最优解的值，通常采用自底而上的方法。
4. 利用计算出的信息构造一个最优解。

## 最优子结构

问题的最优解由相关子结构问题的最优解组合而成，而这些子问题可以独立求解

## 两种等价方法

1. 带备忘的自顶向下法（递归）

2. 自底向上法（迭代）

## 什么时候使用

### 1. 最优子结构

一个问题的最优解包含其**子问题**的最优解

!!! info "怎么发掘最优子结构？"

    1. 做出一个选择
    2. 已知最简子问题的最优选择
    3. 逐步递进选择后，刻画子问题空间（找出规律,尽可能简单，只在必要时扩展）
    4. 积累最优子问题直到目标问题完全由最优子问题构成，此时，目标问题已是最优选择

!!! info "怎么区分不同问题的最优子结构"

    1. 多少个子问题
    2. 每个子问题需要考察多少种选择

    所以时间复杂度即为 **子问题数量** $\times$ **考察多少选择**

    如果$n$个子问题，每个子问题需要做出$n$个选择，时间复杂度为$O(n^2)$

    也可用**图**来做同样的分析。

    1. 图中每个**顶点**对应一个**子问题**
    2. 需要考察的**选择**对应关联至子问题顶点的**边**

!!! info "与贪心算法相比"

    - 相似之处：在于也必须具有**最优子结构**性质
    - 不同之处：贪心算法并不是首先寻找子问题的最优解，然后再其中进行选择，而是首先做出一次**贪心**选择 $\implies$ 在当时看来最优的选择 $\implies$ 然后求解选出的子问题，从而不必费心求解所有可能相关的子问题

!!! info "怎么看问题是否具有最优子结构性质"

    子问题之间无关，同一个原问题的一个子问题的解不影响另一个子问题的解，类似于图的顶点和边被某个子问题占用就不能在被其它子问题占用。

    换个角度来看，求解某个子问题的用到了某些资源（比如顶点），再解其它子问题时不可用，或者说资源不共享，是独占的。


### 2. 子问题重叠

子问题空间必须足够**小**，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。

与之相对的，适合用分治方法求解的问题通常在递归的每一步都生成全新得子问题。

!!! info "子问题重叠在动态规划中的使用"

    对每个子问题求解一次，将解存入一个表中，当再次需要这个子问题时直接查表，每次查表的代价为常量时间。


!!! info "自底向上动态规划与自顶向下备忘算法（递归）"

    - 如果每个问题都必须至少求解一次，动态规划要更快，虽然都是$O(n^3)$（但是相差一个常量系数），但是递归调用有开销，表的维护开销也更小

    - 如果不是每个问题都需要求解，只求解必要的子问题，那备忘方法更有优势

## 最长公共子序列

### 刻画最长公共子序列的特征


${c[i,j]=
\begin{cases}
0 & \quad \text{ 若 } i = 0 \text{ 或 } j = 0\\
c[i-1,j-1] + 1 & \quad \text{ 若 } i,j > 0 \text{ 且 } x_i = y_i\\
max(c[i,j-1],c[i-1,j]) & \quad \text{ 若 } i,j > 0 \text{ 且 } x_i \neq y_i
\end{cases}
}$

<div class="center-table" markdown>
![](https://p.ipic.vip/3vc3ff.jpg){width=300}
</div>


## leetcode

### 剑指 Offer 10- I. 斐波那契数列

=== "1.1刻画一个最优解的结构特征"

    ${
        规律=
        \begin{cases}
        f(0)=0\\
        f(1) = 1\\
        f(2) = f(0) + f(1) = 1\\
        f(3) = f(1) + f(2) = 2\\
        f(4) = f(2) + f(3) = 3\\
        f(5) = f(3) + f(4) = 5\\
        ...\\
        f(n) = f(n-1) + f(n-2)
        \end{cases}
    }$




=== "1.2递归地定义最优解的值"

    $dp(i) = dp(i-2) + dp(i-1)$

=== "1.3计算最优解的值，通常采用自底而上的方法"

    ```java
    class Solution {
        public int fib(int n) {
            if(n <= 1) return n;

            int a = 0,b = 1, sum = 0;

            for(int i = 2;i <= n;i++){
                sum = (a + b)%1000000007;
                a = b;
                b = sum;
            }

            return sum;
        }
    }

    ```

### 剑指 Offer 10- II. 青蛙跳台阶问题

=== "2.1刻画一个最优解的结构特征"

    ${规律=
    \begin{cases}
    f(2) = 11 2 = 2\\
    f(3) = 111 12 21 = 3\\
    f(4) = 1111 211 121 112 22 = 5\\
    f(5) = 11111 2111 1211 1121 1112 122 212 221= 8\\
    f(6) = 13\\
    f(7) = 21\\
    f(n) = f(n-1) + f(n-2)
    \end{cases}
    }$

=== "2.2递归地定义最优解的值"

    $dp(n) = dp(n-1) + dp(n-2)$


=== "2.3计算最优解的值，通常采用自底而上的方法"

    ```java
    class Solution {
        public int numWays(int n) {
            if(n<=2)return n;
            int a = 1, b = 2, sum = 0;

            for(int i=3;i<=n;i++){
                sum = a + b;
                a = b;
                b = sum;
            }
            return sum;
        }
    }

    ```

### 剑指 Offer 63. 股票的最大利润

=== "3.1刻画一个最优解的结构特征"

    `输入[7,1,5,3,6,4]`

    ${规律=
        \begin{cases}
        第一天买，第二天卖，-6\\
        第一天买，第三天卖，-2\\
        第一天买，第四天卖，-4\\
        第一天买，第五天卖，-1\\
        第一天买，第六天卖，-3\\
        i 是买入 j 是卖出，上面的第一天买，第二天卖就是i=1,j=2\\
        i=2,j=3,4\\
        i=2,j=4,2\\
        i=2,j=5,5\\
        i=2,j=6,3\\
        ...\\
        i=5,j=6,-2\\
        i=6,跳出循环\\
        第一天买,最大利润,是不买不卖=0\\
        第二天买,最大利润,是第五天卖=5\\
        第三天买,最大利润,是第六天卖=1\\
        第四天买,最大利润,是第六天卖=3\\
        第五天买,最大利润,是不买不卖=0\\
        最大利润是，前i-1天的最大利润与第i天的价格减去前i-1天的最小价格作比较，取较大值
        \end{cases}
    }$

=== "3.2递归地定义最优解的值"

    $dp(i) = max(dp(i-1), prices(i)-min(prices(i-1)))$

=== "3.3计算最优解的值，通常采用自底而上的方法"

    循环一次，每天都更新最小价格和最大利润

    ```java
    class Solution {
        public int maxProfit(int[] prices) {
            if(prices==null||prices.length==0)return 0;
            int max = 0, min = Integer.MAX_VALUE;
            for(int i=0;i<prices.length;i++){
                min = Math.min(min, prices[i]);
                max = Math.max(max, prices[i]-min);
            }
            return max;
        }
    }
    ```

### 剑指 Offer 42. 连续子数组的最大和

=== "4.1刻画一个最优解的结构特征"

    输入: `nums = [-2,1,-3,4,-1,2,1,-5,4]`
    ${规律=
        \begin{cases}
        [-2]&最大和为{-2}&子数组=[-2]\\
        [-2,1]&最大和为1&子数组=[1]\\
        [-2,1,-3]&最大和为1&子数组=[1]\\
        [-2,1,-3,4]&最大和为4&子数组=[4]\\
        [-2,1,-3,4,-1]&最大和为4&子数组=[4]\\
        [-2,1,-3,4,-1,2]&最大和为5&子数组=[4,-1,2]\\
        [-2,1,-3,4,-1,2,1]&最大和为6&子数组=[4,-1,2,1]\\
        [-2,1,-3,4,-1,2,1,-5]&最大和为6&子数组=[4,-1,2,1]\\
        [-2,1,-3,4,-1,2,1,-5,4]&最大和为6&子数组=[4,-1,2,1]\\
        \end{cases}
    }$

=== "4.2递归地定义最优解的值"

    ${dp(i)=
        \begin{cases}
        nums[i]&dp(i-1)<=0\\
        dp(i-1) + nums[i]&dp(i-1)>0
        \end{cases}
    }$

=== "4.3计算最优解的值，通常采用自底而上的方法"

    ```java
    class Solution {
        public int maxSubArray(int[] nums) {
            int last = Integer.MIN_VALUE;
            int max = last;
            for(int num: nums){
                if(last<=0)last = num;
                else last += num;
                max = Math.max(max, last);
            }
            return max;
        }
    }
    ```