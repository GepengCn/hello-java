# 插入排序 `Insertion Sort`

## 思维导图

![](https://p.ipic.vip/avfy4t.jpg)

## 特性

- 是一种基于**数组插入操作**的排序算法。

## 原理

「插入操作」原理：选定某个待排序元素为基准数 `base`，将 `base` 与其左侧已排序区间元素依次对比大小，并插入到正确位置。

!!! tip "原理"

    - [x] 一次插入

    回忆数组插入操作，我们需要将从目标索引到 `base` 之间的所有元素向右移动一位，然后再将 `base` 赋值给目标索引。

    ![](https://p.ipic.vip/6qava5.png)

    - [x] 插入全流程

    ![](https://p.ipic.vip/5y2nst.png){width=450}

    - [x] 代码

    ```java
    /* 插入排序 */
    void insertionSort(int[] nums) {
        // 外循环：base = nums[1], nums[2], ..., nums[n-1]
        for (int i = 1; i < nums.length; i++) {
            int base = nums[i], j = i - 1;
            // 内循环：将 base 插入到左边的正确位置
            while (j >= 0 && nums[j] > base) {
                nums[j + 1] = nums[j];  // 1. 将 nums[j] 向右移动一位
                j--;
            }
            nums[j + 1] = base;         // 2. 将 base 赋值到正确位置
        }
    }

    ```

## 复杂度分析

**时间复杂度 $O(n^2)$** ：最差情况下，各轮插入操作循环 $n - 1$ , $n-2$ , $\cdots$ , $2$ , $1$ 次，求和为 $\frac{(n - 1) n}{2}$ ，使用 $O(n^2)$ 时间。输入数组完全有序下，达到最佳时间复杂度 $O(n)$ 。

**空间复杂度 $O(1)$** ：指针 $i$ , $j$ 使用常数大小的额外空间。

## 插入排序优势

回顾「冒泡排序」和「插入排序」的复杂度分析，两者的循环轮数都是 $\frac{(n - 1) n}{2}$ 。但不同的是：

- 冒泡操作基于 **元素交换** 实现，需要借助一个临时变量实现，共 3 个单元操作；
- 插入操作基于 **元素赋值** 实现，只需 1 个单元操作；

粗略估计，冒泡排序的计算开销约为插入排序的 3 倍，因此插入排序更受欢迎，许多编程语言（例如 Java）的内置排序函数都使用到了插入排序，大致思路为：

- 对于 **长数组**，采用基于分治的排序算法，例如「快速排序」，时间复杂度为 $O(n \log n)$ ；
- 对于 **短数组**，直接使用「插入排序」，时间复杂度为 $O(n^2)$ ；

虽然插入排序比快速排序的时间复杂度更高，**但实际上在数据量较小时插入排序更快**，这是因为复杂度中的常数项（即每轮中的单元操作数量）占主导作用。这个现象与「线性查找」和「二分查找」的情况类似。