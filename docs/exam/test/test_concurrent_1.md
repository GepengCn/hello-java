- 什么是指令重排序

在指令顺序更改的情况下，不影响最后的执行结果，编译器可以按照自己的规则调用指令执行任务

系统在执行代码的时候不一定是按照代码的执行顺序依次执行

- 编译器优化重排：在不改变单线程程序语义的前提下，重新安排语句的执行顺序
- 指令并行重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变指令的执行顺序

- 什么是主内存？什么是本地内存？

主内存JVM的内存
每个线程都有一个私有的本地内存来存放共享数据的副本，并且每个线程只能访问自己的本地内存

- happens-before 原则是什么？为什么需要 happens-before 原则？happens-before 常见规则有哪些？谈谈你的理解？

分布式环境中，通过一系列规则来定义逻辑时钟的变化，从而通过逻辑时钟来对分布式环境中的事件的先后顺序进行判断。逻辑时钟不度量时间本身，仅区分时间发生的先后顺序，其本质就是定义了一个happens-before关系

为了程序员和编译器处理器之间的平衡。程序员追求易于理解和编程的强内存模型，遵守既定规则编码。编译器和处理器追求的是较少约束的弱内存模型，让它们尽可能的去优化性能，让性能最大化。

所以
- 为了对编译器和处理器约束尽可能少，只要不改变程序结果，怎么进行重排序优化都行
- 对于会改变程序结果的重排序，必须禁止


1. 程序顺序规则：一个线程内，按照代码顺序，写在前面的happens-before后面的
2. 解锁规则：解锁happens-before加锁
3. volatile规则：保证可见性，也即写操作的结果要对读操作可见
4. 传递规则：如果A happens-before B，B happens-before C 那么A happens-before C
5. 线程启动规则：start方法 happens-before 线程中的每一个动作


解锁 happens-before 加锁

- 并发编程三个重要特性

可见性

当一个线程对共享资源进行了修改，那么另外的线程看到的都是修改后的最新值。

java中synchronized或者各种Lock锁、以及原子类都可以保证原子性、以及volatile都能保证可见性

原子性

一次操作或者多次操作，要么全部执行，要么全部不执行

java中synchronized或者各种Lock锁、以及原子类都可以保证原子性

有序性

由于指令重排序，代码的执行顺序未必就是编写代码的顺序

volatile可禁用指令重排

- 如何保证变量的可见性？

volatile关键字修饰
synchronized修饰
Atomic原子类

- 如何禁止指令重排序？

volatile关键字

- volatile 可以保证原子性么?
不能
- 乐观锁和悲观锁

悲观锁：总是假设最差的情况，认为共享资源的一定会被其他资源修改，所以每次获取资源时候都会上锁，这样其他线程就会被阻塞直到锁被释放

乐观锁：总是假设最好的情况，共享资源不会被其他资源篡改，所以无须加锁，只在提交修改的时候验证资源是否被修改

- 如何实现乐观锁？

1. 版本号机制或时间戳，数据库增加一个version字段，每次访问资源都记录下version，当修改资源后准备保存之前，再次读取version，当且仅当version不变的情况下，才更新资源

2. CAS算法

V：变量值
E：预期值
N：新值

当且仅当预期值==变量值时，才将变量值改为新值

- 乐观锁存在哪些问题？

ABA问题，就是读取到的值，如果被其它线程修改过，又改回原值，实际上值已变更过，但是对于乐观锁来说，无法判断，它从两次读取值不变的角度来看，资源并未被修改，但实际上资源已经修改过了。可以增加一个时间戳或者使用AtomicStampedReference原子类

在写多读少的场景下，锁被征用的时间比率较大，乐观锁长时间处于自旋等待，很消耗CPU资源

只能保证对单个共享变量有效，可以用原子类AtomicReference来解决

- synchronized 是什么？有什么用？

是jVM团队基于底层设计的独占锁，可以用来保护共享资源不被并发修改

- 如何使用 synchronized？

1. 修饰实例方法，锁定实例对象

2. 修饰类静态方法，锁定类方法

3. 修饰代码块(对象\类.class)


- 构造方法可以用 synchronized 修饰么？

不能，构造方法本身就是线程安全的

- synchronized 底层原理了解吗？

如果锁定的是对象实例的话，会在访问共享资源之前，调用monitor监视器，即先调用monitorenter,monitor内部的计数器count+1,

然后调度共享资源，最后调用monitorexit，计数器count--

如果锁定的是方法，会在monitor监视器增加一个该方法的同步标识，代表该方法被锁定，资源被征用

- JDK1.6 之后的 synchronized 底层做了哪些优化？

偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗话等技术减少锁操作的开销

将原来的重量级锁，优化为无锁、自旋锁、轻量级锁、重量级锁4个阶段，随着资源征用的情况逐渐升级

- synchronized 和 volatile 有什么区别？

volatile是线程同步轻量级的实现，所以性能要更好

volatile只能保证可见性和有序性，不能保证原子性；synchronized都能保证

volatile只能修饰单个变量；synchronized还能修饰方法

- ReentrantLock 是什么？

基于API开发的可重入、独占锁，支持等待可中断，选择性通知，对共享资源的锁控制更加灵活，支持公平锁

- 公平锁和非公平锁有什么区别？

公平锁：资源的获取顺序是按照请求锁的时间顺序走的

非公平锁：抢占式的，所以有的请求可能永远获取不到资源访问

- synchronized 和 ReentrantLock 有什么区别？

两者都是独占锁，也都是可重入锁

synchronized是JVM团队基于底层研发的独占锁，没有对外暴露实现方式，不支持公平锁

ReentrantLock是基于API开发的，实现方式源码中可见。

除此之外，支持等待可中断，原则性通知、锁的灵活度也更高，支持公平锁

- 可中断锁和不可中断锁有什么区别？

可中断锁：在获取锁等待的过程中，可以选择中断等待

ReentrantLock就是可中断锁，synchronized是不可中断锁

- ReentrantReadWriteLock 是什么？

可重入读写锁，内部有两个锁，读锁和写锁，读写锁互斥，写写锁互斥，读读锁可共享资源访问

- ReentrantReadWriteLock 适合什么场景？

适合读多写少的场景

- 共享锁和独占锁有什么区别？

共享锁：可多个线程并发访问资源

独占锁：每次只有一个线程能访问资源，其它并发线程同步等待

- 线程持有读锁还能获取写锁吗？

不能

持有读锁，不能获取写锁，即使是自身的锁升级也不行

持有写锁，可以获取读锁，仅限读锁是自身的锁，即可重入的情况

- 读锁为什么不能升级为写锁？

如果能的话，读锁升级为写锁，需要其他读锁释放锁，才能升级，但是如果两个读锁都需要升级为写锁，就会形成死锁。

为什么需要其他读锁释放锁呢？因为如果其他读锁不释放，升级为写锁对资源进行修改，就不能保证可见性了

- Atomic 原子类介绍，有哪几种类型，分别介绍一下?
基础类型
AtomicInteger
AtomicLong
AtomicBoolean
数组类型
AtomicIntegerArray
AtomicLongArray
AtomicReferenceArray

引用类型
AtomicReference
AtomicMarkableReference
AtomicStampedReference

对象属性修改类型
AtomicIntegerFieldUpdater
AtomicLongFieldUpdater
AtomicReferenceFieldUpdater


- ThreadLocal 有什么用？

可以用来操作或者读取线程的私有数据，这个数据是每个线程对资源的数据副本，修改了只对自己可见，不会跟其它线程共享或者征用，所以线程安全

- ThreadLocal 原理了解吗？

每个线程都有个ThreadLocalMap变量
ThreadLocal相当于它的句柄，封装了Thread.currentThread()读取或者设置ThreadLocalMap值的方法

- ThreadLocal 内存泄露问题是怎么导致的？

ThreadLocalMap是一个map，key是ThreadLocal本身是一个弱引用，value是强引用，如果忘记手动清理的情况下，一段时间后弱引用会被jvm回收，而value则永远无法被回收，造成内存泄露

- 什么是线程池?为什么要用线程池？如何创建线程池？

将一堆线程资源池化，由线程池来统一创建或销毁线程资源。

1. 线程池创建的线程可以被直接调用，并发频发的情况下，减少线程创建和销毁的时间消耗，提高效率，同时也减少了创建和销毁的成本
2. 通过线程池可以方便对线程进行管理和监控，避免线程的无序创建，极端情况下造成oom等不稳定情况的发生，提升整个服务的稳定性

1. Executors创建
2. ThreadFactory创建

- 为什么不推荐使用内置线程池？

1. 内置线程池，固定线程池的等待队列上线为Integer.MAX_VALUE，缓存队列可以无限制创建线程资源，两种极端情况下都会出现oom
2. 使用ThreadFactory创建线程池可以让开发人员直观的看到线程池的配置情况，更好的对使用场景做定制

- 线程池常见参数有哪些？如何解释？

核心线程数：队列未达到最大容量时，同时运行的最大线程数量
最大线程数：当等待队列满的情况下，同时运行的最大线程数量
等待队列数：当使用线程达到核心线程数，等待队列能够放置的最大线程数
线程工厂：可以传入自定义的线程工厂，一般用来设置线程名，以便后续调试
饱和策略：当使用线程数达到最大线程数时，线程池对新的任务执行的策略
keepAliveTime:大于核心线程数的在空闲时不会立即销毁，会在keepAliveTime时长后销毁
unit:keepAliveTime单位

- 线程池的饱和策略有哪些？

1. 拒绝并抛出异常
2. 拒绝，摸摸丢弃不通知
3. 直接抛弃最老的等待任务
4. 调用提交任务本身的线程来执行线程任务，会降低服务的整体性能，只有在尽可能保证任务执行不能丢弃的场景下适合使用

- 线程池常用的阻塞队列有哪些？

LinkedBlockingQueue

先入先出阻塞队列，无界队列

SynchronizedQueue

同步队列，是一个虚拟的队列，实际上是通过线程之间的前后指针来保证线程的顺序执行

- 线程池处理任务的流程了解吗？

1. 判断是否达到核心队列的上限，没达到则创建线程，达到了则放入等待队列
2. 判断是否达到等待队列的上限，没达到则放入等待队列
3. 如果等待队列已满，判断是否达到最大队列的上限，没达到则创建线程，达到了则通过饱和策略来处理

- 如何给线程池命名？
1. 通过guava的ThreadFactoryBuilder创建线程工厂
2. 写一个自定义线程工厂类，继承线程工厂



- 如何设定线程池的大小？

通过线程工厂

- 如何动态修改线程池的参数？

通过线程工厂的内置方法，如果更改核心线程数小于当前使用线程，会削减当前线程


- Future 类有什么用？

用来获取线程执行后的结果或者对线程进行打断

- Callable 和 Future 有什么关系？

FutureTask是Future的一个实现，内部也是用了Callable来处理返回结果，相当于用于管理Callable的任务情况和返回结果

甚至传入Runnable也会被转换为Callable

- CompletableFuture 类有什么用？

java8中新增的，增强了几个功能

1. 返回的结果由同步获取改为异步获取
2. 可以便捷的将多个线程任务编排组合

- AQS 是什么？

抽象队列同步器，里面定义了一个对共享资源的使用规则

提供一些通用功能的实现，主要用来构造锁和同步器


- AQS 的原理是什么？

如果被请求的共享资源空闲，则将之设置为工作线程，并锁定；否则，需要一套线程阻塞等待以及换形时锁分配的机制。这个机制使用的clh队列锁实现。

clh是一个虚拟的双向队列。实际上AQS将每一个线程封装到一个node结点中，这个结点保存着线程的引用，当前节点的锁定状态以及前驱结点和后继结点。

AQS使用state变量标识同步状态，int型的，使用volatile修饰，比如ReentrantLock，为0就是未锁定，1代表锁定了，大于1说明是可重入了，释放锁就是state--，锁定就是state++


- Semaphore 有什么用？

可以使得多个线程并发共享某个线程资源。支持非公平和公平锁两种，常用于做限流处理使用

- Semaphore 的原理是什么？

通过设置permits，其实就是AQS的state，规则就是每个线程通过tryAcquire获取令牌时，permits--，也即state--。
当permits>0时，可以共享该资源，当permits==0时，资源被锁住，请求线程等待锁释放

- CountDownLatch 有什么用？

允许n个线程阻塞在一个地方，直到n个线程都执行完，才执行后续的代码逻辑

一次性的，再次使用需要重新new

- CountDownLatch 的原理是什么？

同样是构造器传入的值，即为AQS的state值，多个线程，每当执行完，state--，当state==0时，锁释放

- 用过 CountDownLatch 么？什么场景下用的？

并发读取多个文件的内容，最后将内容汇总排序计算等

- CyclicBarrier 有什么用？

多个线程都执行完达到所谓的栅栏时，才执行传入的要执行的方法

- CyclicBarrier 的原理是什么？

CountDownLatch是AQS

CyclicBarrier用的ReentrantLock 显式锁