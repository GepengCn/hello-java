- 介绍下HashMap
底层的数据结构主要是数组

1.7之前是数组+链表
1.8之后是数组+链表或红黑树

链表主要是为了解决hash冲突

红黑树是为了解决hash冲突严重，链表过长，查询慢的问题

- 什么是扰动函数,怎么实现的

就是hash方法，里面是位运算，主要是为了获取数组的下标，对key进行hash&n-1

- jdk8前后有什么变化，为什么？

同上

- 为什么需要链表

解决hash冲突
- 什么是hash冲突

不同的key 通过hash&n-1获取到同一个下标地址

- 为什么要用红黑树？红黑树是什么？红黑树需要满足什么条件？有什么优势？与平衡二叉树的区别？使用场景？

解决链表太长查询慢，链表是On，红黑树是O(logn)，一个特殊的二搜搜索树，增加一个标志位，代表颜色

不是红就是黑
根黑
叶黑
任何一个叶节点的黑高一样
红下面比黑

平衡二叉树，会在极端情况下退化了链表的

avl树，一有删增，就需要旋转树来维持平衡

红黑树，旋转次数少很多，而且不会退化为链表。

hashmap，treemap


- 为什么改为尾插法，头插法有什么弊端

头插法，并发情况下会出现环

- 链表和红黑树转换的阈值是多少，为什么不一样

数组大于64，阈值达到8

6

避免hash碰撞发生在阈值周围，来回的转换

- HashMap怎么扩容

先创建一个新数组，
然后将hashmap的key重新hash复制到新数组里

- HashMap为什么重写equals之后，必须重写hashcode

如果对象作为key的话，不重写hash，每次都用对象去hash，值每次都不一样

- HashMap怎么保证线程安全

Collections.synchronizedMap
HashTable
方法上锁
ConcurrentHashMap

- HashMap是否有序，如果想要有序，有什么方案？

无序，LinkedHashMap

- LinkedHashMap怎么实现有序，有哪些顺序，LRU顺序是什么？算法原理是什么？

里面的结构是双向链表，保存前驱和后继，支持顺序和LRU顺序。最少最近使用。新插入的和重复使用的，会插入到链表头部

- 描述下put操作

先判断是否需要扩容
hash&n-1获取数组下标
判断下标位置是否有值，没值就是插入，有值，从链表往下检索，看是否有同一个值，有的话，更新value，没有的话，写入链表尾部

- 怎么确定捅下标
hash&n-1
- 与hashtable比较
线程不安全，但是性能更好
链表解决hash冲突
hashmap可以插入null key和null value，hashtable不行
- 与hashset比较
hashset，就是存value，不重复的
- treemap描述下？
内部是红黑树
- ConcurrentHashMap描述下？jdk8前后有什么变化？怎么保证的线程安全？

1.7之前是数组+链表+分段锁，保证线程安全的，有个内部类segment，里面保存一段的数组数据，如果是访问不同段的数据，可以并发读写
1.8之后是数组+链表+synchronized修饰链表+cas操作，更新和删除

- hashmap的长度为什么是2的幂次方

可用位运算代替取余操作
位运算更快
hash更均匀

- hashmap的遍历方式

迭代器
lambda
stream api

- hashmap中用了哪些设计模式

迭代器模式