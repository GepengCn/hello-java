## 问题

62分

- 介绍下HashMap  3/5

jdk8之前，数组+链表
jdk8之后，数组+链表+红黑树

- 什么是扰动函数,怎么实现的 3/5
就是hash方法 

- jdk8前后有什么变化，为什么？ 3/5

jdk8之前，数组+链表
jdk8之后，数组+链表+红黑树
红黑树用来解决链表过长，增删查比较慢的问题

- 为什么需要链表 5/5

解决哈希冲突

- 什么是hash冲突 5/5

hashmap通过key的hash值&(n-1)获取元素下标，hash冲突就是多个元素指向同一个下标

- 为什么要用红黑树？红黑树是什么？红黑树需要满足什么条件？有什么优势？与平衡二叉树的区别？使用场景？3+5+0+0+0/25

用红黑树解决链表过长的性能下降问题。红黑树是二叉搜索树，增加了一个标志位存储颜色。

最长的分支不会超过其他分支的两倍，近乎平衡

hashmap,hashtable,ConcurrentHashMap

- 为什么改为尾插法，头插法有什么弊端 2/5

头插法并发时会形成环，造成死循环

- 链表和红黑树转换的阈值是多少，为什么不一样 4/5

链表->红黑树 数组长度大于64，链表长度大于8

红黑树->链表，数组长度小于6

避免在阈值上下增减，链表与红黑树反复转换

- HashMap怎么扩容 3/5

1. 重写创建一个新数组，长度为原来的2倍
2. 将元素重新hash到新数组中

- HashMap为什么重写equals之后，必须重写hashcode 5/5

因为当哈希冲突时，链表中的元素需要通过equals方法来筛选，如果不重写hashcode，会出现用同样的key值获取不到value的情况

- HashMap怎么保证线程安全 5/5

1. Collecitons.synchronizedMap
2. synchronized关键字
3. hashTable替换
4. ConcurrentHashMap替换

- HashMap是否有序，如果想要有序，有什么方案？ 4/5

无序 
1. 使用LinkedHashMap
2. 使用TreeMap

- LinkedHashMap怎么实现有序，有哪些顺序，LRU顺序是什么？算法原理是什么？5/10

LinkedHashMap内部维护了一个双向链表，维护了前置与后置元素的指针。

插入顺序与LRU顺序

LRU,最少最近使用算法，使用双向链表，头部存储最新的元素

- 描述下put操作 4/5

1. 通过hash&(n-1)获取元素下标
2. 判断该下标是否已存在链表元素
3. 已存在遍历链表，通过equals方法比较目标元素是否存在链表中，如果存在，则替换该元素的value；如果不存在，则通过尾插法，插入链表尾部
4. 如果不存在链表元素，则创建新链表，将元素插入链表

- 怎么计算hash值 0/5

1.8之前位运算
1.8之后优化了运算，少了4次运算

- 怎么确定捅下标 5/5

hash&(n-1)

- 与hashtable比较 5/10

hashtable增删改增加了synchronized关键字，保证线程安全
hashmap非线程安全

hashtable初始值11，每次扩容2n+1,指定初始容量为多少即是多少
hashMap初始16，每次扩容是原长度的2倍，指定初始容量后会扩容为2的幂次方


- 与hashset比较 3/5

hashset内部维护着hashMap

hashmap存储键值对， key能存储null，但只有一个，value能存储null，不限制

hashset只存储值，value不能存储null，否则会抛异常

- treemap描述下？4/5

底层数据结构是红黑树，所以天然支持排序，增删查的时间复杂度为O(logn)

- ConcurrentHashMap描述下？jdk8前后有什么变化？怎么保证的线程安全？8/10

jdk8之前是分段数组+链表组成，内部维护了一个Segment类，每个Segment维护一组数据，通过显示锁保证线程安全，并发数即是Segment的数量，不同线程可以并发访问不同的Segment上的元素

jdk8之后是数组+链表/红黑树组成，通过synchronized关键字+CAS操作实现线程安全，synchronized关键字只修饰单个元素，并发能力大幅增强，CAS实现乐观锁来增删查询元素，volitile关键字修饰链表元素

- hashmap的长度为什么是2的幂次方 8/10

1. 可以用位元素替换求余运算，提升效率
2. 是的hash更均匀，长度为2的幂次方时，n-1的2进制都为11-11，在进行位运算，减少重复，使得hash更均匀，减少hash冲突，使得数组下标能被充分利用

- hashmap的遍历方式 3/10

1. 迭代器模式
2. ForEach方式
3. Lambda方式
4. Streams API方式

- hashmap中用了哪些设计模式 5/5

迭代器模式