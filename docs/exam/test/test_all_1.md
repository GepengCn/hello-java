- 介绍下HashMap
jdk1.8之前是数组+链表的结构
数组是数据存储的主题，hashmap的快速随机访问主要就是数组结构的快速访问实现的，随机是通过hash算法获取对应的数字下标，链表是用来解决hash冲突，hash算法的弊端就是有几率会出选，不同的key通过hash算法产生同一个数组下标，这时候就通过链表来解决

1.8以及之后用的是数组+链表+红黑树的结构，红黑树是为了解决哈希冲突严重链表过长，查询缓慢的问题，当数组长度大于64，链表大厂大于8，链表会转换为红黑树，链表查询时间复杂度是O(n)，红黑树是O(logn)
还有一个改变就是1.8用尾插法代替头插法，解决头插法并发情况下，可能出现环造成死循环的问题


- HashMap怎么扩容

先创建一个新数组，是原来的2倍
然后将原数组里的数据，重新hash获取数组下标，复制到新数组


- HashMap怎么确保线程安全

Collections.synchronizedMap来转换成同步map
用HashTable
最好的是用ConcurrentHashMap来代替

- 描述下HashMap的put

先判断map是否需要扩容，如果达到阈值，先扩容，负载因子0.75

然后通过hash算法，获取对应的数组下标，hash&(n-1)获取的

每个数组元素都是个链表，先遍历链表，看链表是否为空，为空，直接插入链表，不为空，说明有hash冲突，在判断，当前key是否已存在，通过equals方法判断，如果存在，更新value，如果不存在，插入链表


- 红黑树

一种特殊的二叉查找树

给每个结点，增加了一个颜色位，用来存储红黑两色

他的每个叶子节点，到根节点的黑高，必然是一样的，保证每个叶节点，不会超过其它结点的两倍

规则：
每个结点或红或黑
根黑
叶黑
叶结点黑高必然一样
红底下必黑，不能红

增删改的时间复杂度都是O（logn）

相比如二叉搜索树，他不会退化成链表
相比如avl树，他不用每次插入或删除数据都要旋转树，只有破坏了规则才会，大大减少了旋转的次数，性能还不差



- osi七层模型是什么

- 应用层：终端的一些应用，比如浏览器，用来具体实现协议的层
- 表示层：加解密，解压缩等等
- 会话层：建立管理会话的
- 传输层：定义传输协议和端口的，比如tcp，udp再次层
- 网络层：路由，寻址
- 数据链路层：帧编码和误差修正，比如将物理层的mac地址进行封装和解封
- 物理层：定义物理设备标准，主要用来传输比特流


- tcp/ip四层模型

应用层：定时数据交换协议，http ftp等再此层
传输层：定义数据传输的协议，udp，tcp再此层
网络层：路由，寻址
网络接口层：数据链路层和网络层的合并，用来帧编码和比特流传输

- 从输入url到页面展示发生了什么？

1. dns解析，将域名转换为ip地址
2. 建立tcp链接
3. 发送http请求到服务端
4. 服务端接收并处理，然后返回结果
5. 浏览器通过结果渲染数据
6. 断开链接

- tcp三次握手

客户端发送syn给服务端，然后客户端处于syn-send
服务端收到后，返回syn+ack，服务端处于syn-rec
客户端收到后，再返回ack，然后客户端服务端，都处于estabilash状态



- tcp四次挥手

客户端发送fin给服务端，然后处于fin-wait-1
服务端收到后，返回ack，然后服务端处于close-wait，客户端处于fin-wait-2
服务端在没有数据传输后，再发送一个fin给客户端，处于close状态，关闭连接
客户端再返回一个ack，然后等待2msl如果没有服务端返回，就会彻底关闭连接


- 为什么要三次握手

为了让双方都确认对方的收发都是正常的

- 为什么要四次挥手

因为双方都需要在彻底关闭之前，确认双方都已发送完残留的数据，才能彻底关闭

- 服务器为什么连发两次挥手

第一次是表明收到客户端要断开连接的请求，但是此刻服务端可能还没发送完，只有真正发送完，再返回一次挥手，才会确保服务端不会丢失数据，彻底可以关闭

- 为什么第四次挥手要等2msl

因为客户端返回的ack可能会丢失，如果客户端不等带直接关闭，服务端再没有收到ack的情况下，会不断给客户端重发fin而无法正常关闭。



- tcp如何保证传输的可靠性

1. 分块传输
2. 数据验证
3. 失败重传

- 什么是指令重排

就是程序执行的顺序未必是你代码写的顺序

编译器重排：jvm会在不影响单线程语义的情况下，重排代码执行的顺序
处理器重排：主要靠的是cpu的指令并行技术做的


- happens-before原则

分布式环境中，任务执行的顺序不是简单的时间顺序，而是有一系列规则定义的逻辑时钟顺序，它定义了程序执行的先后顺序。

线程start规则：start方法 hb 其它操作
传递规则 a hb b b hb c 那么 a hb c
锁规则：解锁 hb 加锁
代码顺序：后面的代码 hb 前面的代码


- 并发编程三原则是什么？

原子性：一个操作或一些列操作，要么全部执行成功，要么全部执行不成功
可见性：并发访问共享资源的多个线程，如果某个线程写操作，必须保证对其它读的操作可见
有序性：禁止指令重排，不能影并发情况下，最后的执行结果

- 乐观锁和悲观锁

悲观锁：假设最坏的情况，共享资源一定会被修改，所以每次请求共享资源，必须得先上锁，用完再解锁。syn reen都是
乐观锁：假设最好的情况，共享资源一定不会被修改，所以不需要加锁，只需要再修改之前，判断下是否被修改了，如果没被修改，cas操作去修改，如果被修改过，则终止

- sync的底层原理

其实都是对monitor对象的获取，通过对锁的计数器+1 -1来上锁和解锁

区别是
修饰方法用的是ACC_SYNC标识，这个方法是同步方法

修饰代码块是通过monitorenter和monitorexit指令，进入方法前调monitorenter指令上锁，方法执行完调monitorexit指令解锁

- reentrantlock是什么

是一个悲观锁，独占锁，可重入锁，是通过jdk api实现的

支持等待可中断、自定义通知、公平锁等功能


- reentrantlock和sync区别


sync是jvm团队开发的，很多优化比如自旋锁、偏向锁、锁粗化等没有对外开放

reentrantlock是基于jdk开发的，实现是可见的，都是独占锁和可重入锁，但是reentrantlock更加的灵活，不局限于修饰方法、代码块，它可以在更大的代码区间做上锁和解锁的操作，reentrantlock支持等待可中断、可选择通知、公平锁等，sync只能notify随机一个，或者notifyall所有，也不支持等待锁释放中断的，只支持非公平锁

- ThreadLocal了解吗

相当于线程私有存储空间的一个句柄，每个线程内部都有一个ThreadLocalMap，key是ThreadLocal本身，value就是私有的变量

常用于保存线程私有的数据的副本，线程间互不干扰，非共享的数据，不存在线程安全问题

- 讲讲线程池

一个统一管理、监控批量线程的池子

1. 获取线程资源更高效，不需要重新创建，直接从池子里获取
2. 节省资源，不用每次使用线程都需要创建和销毁
3. 更容易监控管理，避免线程创建太多溢出


- AQS

一个对共享资源的一个抽象类

它定义了怎么去获取共享资源，比如一个线程请求共享资源，如果空闲的，将这个线程设置为工作线程，相当于上锁，其它线程如果也请求，就需要阻塞同步等待锁释放，以及锁释放，怎么唤醒等待线程，很多锁、同步器都是通过它来实现的，比如reentrantlock，共享锁semphore，countdownlatch，读写锁

讲讲countdownlatch

用aqs实现的，aqs有个计数器state，对应的就是构造器的传值

new一个countdownlatch就是state>5，
await后面就是被阻塞等待唤醒的线程

countdown()方法，就是state--，释放锁，当state=0时，所释放，await后面的程序可以执行了

说白了就是让多个线程并发执行，并在全部执行成功之后再执行后续逻辑的一个工具类

一般用于，多线程计算，然后同意计算，比如读取多个文件内容，整个内容

- 运行时数据区域

1.8之前


共享区域：堆、运行时常量池、方法区
私有区域：虚拟机栈、本地方法栈、程序计数器
本地内存：直接内存 nio

1.8之后

共享区域：堆
私有区域：虚拟机栈、本地方法栈、程序计数器
本地内存：直接内存、云空间（运行时常量池、方法区）


- 堆

jvm内存最大的一块区域，用于存放对象，也是垃圾收集器收集的区域，也叫gc堆

- java对象的创建过程

- 准备：读取字节流，将静态字节流转换为动态运行时，内存中创建一个对象作为入口
- 验证：验证是否符合jvm虚拟机安全
- 分配：分配内存，和初始值，只分配类的变量初始值
- 初始化：执行cinit方法，然后执行真正的程序初始化逻辑
- 使用和销毁

- 死亡对象判断方法

1. 引用计数法
2. 可达性分析算法，验证gcroots对象，向下追溯，标记的是有引用的对象，没标记的就是没有引用的了，可被回收

- 垃圾收集器知道吗？分别讲讲

serial 单线程收集器
serial old 老年代的收集器
parallel old seria的多线程收集器

cms收集器

主打低停顿

初始标记
重新标记
并发标记
并发清除

g1收集器

主打可预测的停顿和高吞吐量，本身就有分区概念，自己就有分代的概念

初始标记
并发标记
最终标记
筛选清除

zgc，把停顿时间进一步的优化


- 类加载器了解吗？双亲委派了解吗？

BootstrapClassloader 加载jdk核心类
extension：加载jdk ext目录下的扩展类
app：加载classpath下的
自定义的

双亲委派，就是类加载在自己加载类之前，要先判断，父类能否加载，先交给父类去加载，只有没有父类，或者父类无法加载的情况下，才会尝试自己加载


- mysql有什么优点

1. 开源免费
2. 成熟稳定
3. 文档丰富
4. 社区活跃
5. 支持事务、崩溃可恢复
6. 插件式引擎架构，支持多引擎
7. 性能好

- mysql基础架构

连接器：验证权限和授权的
查询缓存
分析器：校验语法
优化器：优化sql语句
执行器：执行sql，查询存储引擎的
存储引擎：插件式架构，支持多种

- 存储引擎讲讲？
插件式架构，可以为每个表配置一种引擎，支持多种引擎，myisam innodb，csv等等，5.5.5之前默认是myisam，之后是innodb

- 索引为什么要用b+树？用别的不行吗？

哈希：哈希冲突
二叉树：极端情况下会退化为链表结构
alv数：插入删除频繁，会一直旋转
红黑树：数据量大，树高太高，也会变慢
b+树：数据量，树也不会太高

- 聚簇索引和非

聚簇索引，就是索引和数据存在一块，innodb就是这种结构

优势就是b+树的结构，查询很快
范围索引查询快，结点都是相连的

缺点
需要有序，插入数据后需要保持有序
更新索引，也要更新数据，比较消耗资源

非：

更新资源比较轻量

缺点:
有序
二次搜索，查完索引，还需要查数据

- 最左匹配原则？


联合索引由左向右，依次和查询语句里的字段由左向右，依次去匹配？匹配上，就走联合索引

- 事务隔离界别

读取未提交：不能防止脏读、不可重复度、幻读
读取已提交：不可重复度、幻读
可重复度：幻读
串行


- sql在数据的执行过程


查询

先连接器校验权限
查询缓存
分析器校验语法
优化器进行sql优化
执行器调用存储引擎返回结果


更新：

先查询
然后修改查询的数据
然后写入存储引擎，写入redolog，并处于准备状态，然后写入binlog记录更新，然后redolog，处于提交状态

- 怎么分析explain

select_type:看simple_query、子查询、where后查询、union查询

type:const关联一条数据，一般都是用主键或者唯一索引作为查询条件，ref，普通索引，index_merged 多个索引 eq_ref:链表查一个，关联的是索引 range，索引范围查询 index：整个索引 all：全表扫描


key：实际用到的索引
possible_key:可能用到的索引


- 主键一定是自增的吗？

不一定

手动设置了id，或者自增步长不为1
唯一索引冲突
事务回滚
批量插入，一次性申请了一段id，用不完也不退



- 常用缓存策略

旁路缓存

redis db同步更新，但是以db为主，查不到缓存，查db然后写入缓存，查得到，就直接返回，更新先db，缓存自己去更新db

缓存穿透

缓存为主，查询到缓存，直接返回，查询不到查询db，然后更新缓存，更新先更新缓存，缓存再去更新db

异步缓存

缓存为主，读写都在缓存，然后异步的去同步到db

- Redis支持哪些数据结构

String：字符串，token、session、分布式锁
List：双向链表，范围查询很简单
Set：不可重复的随机查询
ZSet：有序set
哈希：快速随机查询

- Redis持久化机制了解吗？如何选择呢？

rdb：定时保存数据镜像
aof：有数据更新，就会保存aof缓冲区，然后存储到aof文件，根据持计划策略，选择保存到磁盘的时机
混合：aof重写的时候，把rdb写入到aof文件的前面

rdb：适合实时性没那么强的，保存的文件经过压缩，更小，但是可读性不行
aof：实时更新，安全性更高，但是aof文件会很大，里面保存的都是执行语句，没有压缩，即使重写也不小

- Redis有哪些应用呢

分布式锁，内存数据库，pubsub，消息推送

- 如果基于redis设计分布式锁

setIfAbsent，这个操作就是只有没值的情况下，才会写入成功，算是一个原子操作，用这个作为加锁的功能，最好加个超时时间，避免解锁没执行，锁永远不释放

delete，就是解锁

- 过期的删除策略是什么呢？

惰性删除：只有查用到这个key的时候，才回去判断，是否过期删除
定期删除：每隔一段时间，选择一批删除

- 和mecached区别

1. redis可以持久化
2. 崩溃可恢复
3. 分布式的
4. 支持更多的数据格式
5. pub/sub
6. 支持集群


- bio nio aio 区别

bio 同步非阻塞 读写都在一个线程内完成
nio 同步非阻塞，基于通道和缓冲区的，支持io多路复用
aio：异步非阻塞，基于时间和回调的，io处理就绪会执行回调函数，不用同步等待，nio需要等待io就绪

- netty

- 高性能的网络io框架
- 基于nio的
- 支持io多路复用

- 为什么不直接用nio

1. 实现起来比较复杂，还有一些bug
2. 粘包拆包、心跳等实现复杂

- 为什么用Netty？

1. 使用简单，模型强大
2. 稳定高性能
3. 粘包拆包，有很多自带的实现，不必自己实现
4. 简单tcp、udp开发
5. 社区活跃
6. 文档丰富
7. 有很多成熟产品都在用它，证明它非常好用，比如Dubbo，gRPC， rocketmq

- 哪些应用场景

1. web服务
2. 消息推送
3. 即时通讯
4. rpc

- 哪些开源项目用到

Dubbo，gRPC， rocketmq、es

- 介绍下核心组件


BootstrapServer引导类

NioEventLoopGroup配置netty模型

Channel操作读写的

ChannelPipeline：注册通道处理类的链

ByteBuf，操作数据的是nio ByteBuffer的封装


- NioEventLoopGroup启动多少线程

cpu*2

- Netty服务端和客户端启动流程了解吗?


1. 先注册这个Netty的reactor模型，一般是一个worker作为处理新来的请求，构造器不传的情况下，是cpu*2个线程，是io多路复用的
boss是io处理的

然后用bootstrap引导类，把模型注册上去，再注册channel处理类，包括自定义的处理handler，然后注册端口和主机，最后执行sync方法启动服务

可以用channelfuture监控netty服务是否启动

再加一个优雅停机，一般在服务里面加个Runtime.getShutdownHook，监控服务停机，里面worker.shutdowngracefully,boss.sy


- 什么是tcp粘包拆包？怎么解决？

就是客户端一次性发送多条，被揉在一起，或者发送个打包，被拆分成多个了

使用一些自带的粘包拆包解析器

LineBasedFrameDecoder 按大小、自定义字符的、http协议的

- netty长连接心跳机制了解吗？

客户端和服务端，在一段时间内没有交互数据，会由一段，一般是服务端发送个心跳包给对方，也就是ping，客户端收到后，返回pong，相当于告知对方我在线

避免双方谁掉线了，对饭不知道

- Netty零拷贝了解吗？


- Netty使用nio，直接可以在堆外分配内存，避免数据在堆内外来回拷贝
- ByteBuf 封账了ByteBuffer，操作对象，避免了拷贝
- Netty可以把多个ByteBuf合成一个或者一个拆分成多个，其实每个ByteBuf的操作的对象内存地址是没变的，合并也是逻辑合成的
- FileRegion文件传输的时候，通过将文件流直接写入缓存通道，而不用write形式的，避免了拷贝

- 谈谈对于Spring ioc的理解

依赖注入，控制反转，其实就是说创建对象不用我们来手动控制，而是交给Spring容器来做，对象的创建与销毁都是Spring来控制

- 什么是Spring Bean
交给Spring来控制证明周期的bean

- 将一个类声明为bean的注解有哪些


@Component、@Service
@Resposity @Controller @RestController

@Autowise
@Bean

@Component和@Bean

@Component是把一个类，转换为Spring Bean
@Bean只能修饰方法，相当于让bean的构造更灵活一点，可以配置一下构造过程，适用于引入第三方组件的形式，比如redis kafka等等


- bean的作用域有哪些

@Singleton
@ProtoType
@Request
@Session
@Websocket


- bean的生命周期

查询配置文件，获取bean的定义
反射创建bean的实例
如果实现Bean*Aware接口的类，初始化会调用对应的setBean*方法
有实现BeanPostProcessor的，会实现里面的before和after方法，在bean初始化前后
initializingBean的，会执行afterProperties方法
配置文件有init-method，会执行对应方法
相对应的destroy，销毁时会执行
实现了disposableBean接口的，销毁时会执行destroy方法

- Spring aop的理解

把一些与业务不直接相关的通用逻辑，抽象出来

比如日志，监控，入参校验，出参检查、或者出入参一些转换等等

- SpringMVC的理解

将web的开发模式，分层，entity dao service controller层

让各个层都负责单独独立的内容，让开发的模式更容易理解和维护

