- 运行时数据区域概述

1.7之前
共享区域：堆、方法区、运行时常量池
私有区域：虚拟机栈，本地方法栈，程序计数器
本地内存：直接内存

1.7之后
共享区域：堆
私有区域：虚拟机栈，本地方法栈，程序计数器
本地内存：直接内存、元空间（方法区、运行时常量池）

- 程序计数器

字节码的行号指示器，字节码解释器通过改变它的值选取下一条要执行的指令。跳转，循环，线程恢复等等，都需要它

- Java 虚拟机栈

java方法都靠它来实现，生命周期跟方法一样

调用方法，栈帧写入虚拟机栈，方法执行完，栈帧出站

栈帧包括：
局部变量表，编译时的各种对象类型和对象引用
操作数栈，方法执行过程中的中间数据和临时变量
返回地址，正常返回和异常返回
动态链接：符号引用转换为直接引用

- 程序运行中栈可能会出现的错误

StackOverflowError：虚拟机栈不是动态扩展的，如果方法调用过深，超过栈的深度
OutOfMemoryError：是动态扩展的，但是申请不到方法调用需要的内存


- 本地方法栈
调用本地方法的

- 堆

内存最大的一块区域，主要用于保存对象，也是垃圾回收主要收集的区域

- 堆可能出现的错误

内存溢出，jvm内存空间不够了
fullgc之后，回收不了多少内存

- 方法区

保存类的信息，方法信息，变量引用等

- 方法区和永久代以及元空间是什么关系呢？
接口和实现类
- 为什么要将永久代替换为元空间呢?


永久代内存不能扩展，内存溢出的几率高

- 运行时常量池

保存符号引用、字面量

- 字符串常量池

为了提升字符串读写效率

- JDK 1.7 为什么要将字符串常量池移动到堆中？

gc效率更高，内存回收率高

- 直接内存

jni方式直接在堆外分配内存

- 直接内存怎么在java中应用的

nio

- Java 对象的创建过程

加载：加载字节楼，将静态存储结构，转换为运行时数据结构
验证；验证类中没有能危害虚拟机的
准备：赋值初始值
解析：符号引用转换为直接引用
初始化：调用cinit方法，然后执行真正的处理话流程
使用和销毁

- 内存分配的两种方式



- 内存分配并发问题

cas+失败重试
tlab中分配

- 对象的内存布局

对象头
实例数据
对齐填充

- 对象的访问定位

直接指针
句柄

- 内存分配和回收原则

大对象直接进入老年代
长期存活的进入老年代
分配担保
对象优先在edan区分配


- 主要进行 gc 的区域

年轻代：minorgc
老年代：oldgc

- 空间分配担保

确保minorgc之前，老年代还有容纳新生代的空间，有minorgc，没有fullgc

- 死亡对象判断方法

引用计数法

可达性分析算法：沿着GC Roots对象，向下追溯，路过的对象都标记上，未标记的就是没有引用的对象

- 哪些对象可以作为 GC Roots 呢？

虚拟机栈中引用的对象
本地方法栈中引用的对象
类静态变量
常量
锁占用的

- 对象可以被回收，就代表一定会被回收吗？

不一定，可能会经过二次标记

经过可达性分析算法一次标记之后，如果该方法没有实现finilaze方法，就是可回收对象，如果实现了，并且没执行，会放入fqueue队列，进行第二次标记，等待异步去执行

- 引用类型有哪些
强
软
弱
虚

- 如何判断一个类是无用的类？

所有实例被回收
所有的类加载器倍回收
不能通过任何方式引用该类，也不能通过反射调用类的方法

- 垃圾收集算法有哪些？

标记清楚
标记整理
复制
分代

- 垃圾收集器有哪些？
serial old

parallel 多线程 old

cms 并发标记清除


g1
- 类加载器介绍

boot
ex
app

- 双亲委派模型介绍

先不加载，交给父，父不，再自己加载

- 双亲委派模型的执行流程

已加载，返回，否则交给父，父不，自己加载

- 双亲委派模型的好处

保证核心api不被篡改，系统稳定性
- 打破双亲委派模型方法

loadClass