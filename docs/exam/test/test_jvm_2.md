- 运行时数据区域概述

1.8之前

数据共享：堆、方法区、运行时常量池
私有：虚拟机栈、本地方法栈、程序计数器
直接内存：本地内存

1.8之后
数据共享：堆
私有：虚拟机栈、本地方法栈、程序计数器
直接内存：本地内存、元空间（方法区、运行时常量池）

- 程序计数器

线程的解释器通过计数器的改变，来选去下一条要执行的指令。分支、跳转、循环、异常、线程挂起、恢复，都是靠它。

- Java 虚拟机栈

方法调用栈，所有的java方法都是靠它，方法创建伴随着栈帧入栈，方法执行完，栈帧弹出。

栈帧包括：
局部变量表：编译时的变量的数据类型和引用
动态链接：符号引用转换为直接引用
返回地址：正常返回和异常抛出，伴随着栈帧出栈
本地方法区：方法执行过程中产生的中间计算数据和临时变量



- 程序运行中栈可能会出现的错误

StackOverFlowError:如果虚拟机栈不能动态扩展是固定的，如果方法的调用深度超过最大深度
OutOfMemoryError:如果可以动态扩展，但是申请不到新的栈空间

- 本地方法栈

与虚拟机栈类似，它是用来监控本地方法的

- 堆

内存最大的一块区域，所有共享变量存储的区域，对象存储的区域，也是jvm回收的主要区域

- 堆可能出现的错误

1. 没有足够的堆空间分配内存
2. fullgc多次，回收不了多少内存

- 方法区

存储类的详细信息，类信息、类静态变量、常量、引用类型信息等

- 方法区和永久代以及元空间是什么关系呢？

相当于接口和实现类

永久代和元空间相当于方法区的两个具体实现，永久代是1.7之前的，元空间是1.7之后的

- 为什么要将永久代替换为元空间呢?

永久代之前存储在堆中，内存固定，不易扩展
元空间直接放在本地内存上，内存灵活易扩展

- 运行时常量池

符号引用，各种常量存储

- 字符串常量池

为了提高字符串的效能，而做的一个池子。常用字符能被复用，不必每次都创建

- JDK 1.7 为什么要将字符串常量池移动到堆中？

在堆中，容易被垃圾回收期回收，节省内存占用

- 直接内存

java是通过jni间接调用堆外的内存，避免数据在堆内外来回复制

- 直接内存怎么在java中应用的

nio，通过jni的方式，在堆外分配内存，然后通过DirectByteBuffer对象，引用这部分内存。避免数据来回复制，某些场景下大幅提升性能。

- Java 对象的创建过程

校验



初始化

- 内存分配的两种方式



- 内存分配并发问题
- 对象的内存布局
- 对象的访问定位



- 内存分配和回收原则
- 主要进行 gc 的区域
年轻代，minorGC
老年代，oldGC、majorGC

全部：fullGC
- 空间分配担保



- 死亡对象判断方法

引用计数法

可达性分析算法，用一些列可以作为GCRoots的对象，往下追溯并标记所有的对象，被标记的，说明正在用，没被标记的，代表不可用

- 哪些对象可以作为 GC Roots 呢？

1. 类静态变量
2. 常量
3. 锁占用的变量


- 对象可以被回收，就代表一定会被回收吗？

不一定，需要经历两次标记，先通过可达性算法，标记一次，如果第一次没被标记的也不会立刻被回收，会判断是否有finilize方法，如果没执行尝试执行，如果已执行直接回收。
第二次扫描到它，会放入一个队列，如果确认没有引用，就会真正的回收

- 引用类型有哪些

强引用：无论如何都不会被回收，即使内存不够，宁可内存溢出
软：只要内存够，就不会被回收
弱：只要垃圾回收期扫描到它就会回收
虚：随时被回收，主要用来监控jvm的回收器的

- 如何判断一个类是无用的类？

- 所有对象实例都被回收
- 所有类加载器都被回收
- 类无法被任何地方被引用，也不能通过反射引用

- 垃圾收集算法有哪些？

标记、清除，先标记，然后直接清除，会出现不连续的内存碎片
标记、整理，先标记，然后向一端移动，端外的会被回收掉。没有内存碎片，但是移动标记消耗性能
复制：分成两部分堆空间，先用一个，当这个空间内存不足，会将存活对象向另一个空间移动，然后剩余的对象会被全部清理掉。占用一般的空间，可用空间变小
分代：年轻代用复制，老年代用标记整理

- 垃圾收集器有哪些？

serial serial old

parallel parallel old

cms

主打的低停顿时间

初始标记
并发标记
重新标记
并发清除

g1

主打的可预测停顿，高吞吐，充分利用多核cpu

初始标记
并发标记
最终标记
筛选回收


zgc

- 类加载器介绍

BootstrapClassLoader
ExtensionClassLoader
AppClassLoader
CustomClassLoader

- 双亲委派模型介绍

加载某对象，自己先不加载，交给父级加载，只有父级加载不了，才会尝试自己加载

- 双亲委派模型的执行流程

先判断是否加载过，加载直接返回
如果未加载，交给父级加载
父级加载不了，尝试自己加载

- 双亲委派模型的好处

保证jdk核心的类的安全，比如Object对象等，不会被自定义的Object覆盖影响

- 打破双亲委派模型方法

重写loadClass

- 显式指定堆内存
- 显式新生代内存
- 显式指定永久代/元空间的大小
- 指定垃圾回收垃圾器
- GC 日志记录
- 处理 OOM 配置
- 查看所有 Java 进程
- 监视虚拟机各种运行状态信息
- 实时地查看和调整虚拟机各项参数
- 生成堆转储快照
- 分析 heapdump 文件
- 生成虚拟机当前时刻的线程快照
- JVM线上问题排查和性能调优案例