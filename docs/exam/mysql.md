# MySQL

## 问题

- 什么是关系型数据库？
- MySQL 有什么优点？
- MySQL 基础架构
- MySQL 支持哪些存储引擎？默认使用哪个？
- MySQL 存储引擎架构了解吗？
- MyISAM 和 InnoDB 有什么区别？
- 索引介绍
- 索引的优缺点
- 索引底层数据结构选型
- 什么是B树&B+树
- B 树& B+树两者有何异同呢？
- 聚簇索引介绍?聚簇索引的优缺点?
- 非聚簇索引介绍?非聚簇索引的优缺点?
- 非聚簇索引一定回表查询吗(覆盖索引)?
- 覆盖索引
- 联合索引
- 最左前缀匹配原则
- 正确使用索引的一些建议
- MySQL三大日志(binlog、redo log和undo log)详解
- 事务隔离级别
- InnoDB 实现的 REPEATABLE-READ 隔离级别为什么可以解决幻读问题
- SQL语句在MySQL中的执行过程
- 什么是执行计划？
- 如何获取执行计划？
- 如何分析 EXPLAIN 结果？
- MySQL自增主键一定是连续的吗
- MySQL时间类型数据存储建议
- MySQL隐式转换造成索引失效

## 答案

### 什么是关系型数据库？

!!! tip "什么是关系型数据库？"

    关系模型来组织数据，以行和列的形式存储数据

### MySQL 有什么优点？

!!! tip "MySQL 有什么优点？"

    1. 成熟稳定
    2. 开源免费
    3. 文档丰富
    4. 社区活跃
    5. 事务支持优秀
    6. 支持分库分表、读写分离、高可用


### MySQL 基础架构

!!! tip "MySQL 基础架构"

    - 连接器:身份认证和权限相关
    - 查询缓存:查之前，先查缓存，mysql8移除了
    - 分析器:先看sql要干嘛，再检查语法
    - 优化器:按mysql认为的最优方案执行优化
    - 执行器:执行语句，然后从存储引擎返回数据。
    - 存储引擎: 存储和读取数据，插件式架构，支持innoDB、MyISAM等


### MySQL 支持哪些存储引擎？默认使用哪个？

!!! tip "MySQL 支持哪些存储引擎？默认使用哪个？"

    InnoDB, MyISAM

    MySQL 5.5.5之前默认是MyISAM
    MySQL 5.5.5之后默认是InnoDB


### MySQL 存储引擎架构了解吗？

!!! tip "MySQL 存储引擎架构了解吗？"

    插件式架构，支持多种存储引擎。存储引擎是基于表的，而不是数据库，可以为不同的表设置不同的存储引擎

### MyISAM 和 InnoDB 有什么区别？

!!! tip "MyISAM 和 InnoDB 有什么区别？"

    - MyISAM 不支持事务和行级锁，只支持表级锁，而且最大的缺陷就是崩溃后无法安全恢复。
    - MyISAM 不支持事务
    - MyISAM 不支持外键
    - InnoDB支持 MVCC
    - 索引实现不一样，InnoDB数据就是索引，MyISAM索引和数据分离
    - InnoDB性能更好，随着cpu核心增多，性能线性增长


### 索引介绍

!!! tip "索引介绍"

    用于检索数据的数据结构，类似于书的目录

### 索引的优缺点

!!! tip "索引的优缺点"

    - [x] 优点

    - 加速检索速度
    - 唯一索引保证唯一性

    - [x] 缺点

    - 创建索引有耗时
    - 存储索引耗费空间

### 索引底层数据结构选型

!!! tip "索引底层数据结构选型"

    - 哈希表 有哈希冲突
    - 二叉查找树(BST)，不平衡的时候退化为线性
    - AVL树，频繁旋转降低性能
    - 红黑树 数据量大的时候树太高，性能变差
    - B树&B+树

### 什么是B树&B+树

!!! tip "什么是B树&B+树"
    B 树也称 B-树，多路平衡查找树
    B+ 树是 B 树的一种变体

### B 树& B+树两者有何异同呢？

!!! tip "B 树& B+树两者有何异同呢？"

    - B树所有节点既存key也存数据，B+树只有叶节点存key和数据，其它节点只存key
    - B+树叶节点是相连的，所以范围查询只需要遍历即可
    - B+树查询时间复杂度固定位O(logn)，B树不固定，最好为O(1)，最差为O(n)

### 聚簇索引介绍?聚簇索引的优缺点?

!!! tip "聚簇索引介绍?聚簇索引的优缺点?"

    索引结构和数据一起存放,InnoDB 中的主键索引就属于聚簇索引

    - [x] 优点

    - 查询速度非常快:B+树
    - 范围查找速度快：叶结点相连

    - [x] 缺点

    - 依赖有序，所以需要插入排序
    - 更新数据，还要更新索引，代价大。一般主键都是不可被修改的

### 非聚簇索引介绍?非聚簇索引的优缺点?

!!! tip "非聚簇索引介绍?非聚簇索引的优缺点?"

    索引结构和数据分开存放， MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

    - [x] 优点

    - 更新代价小

    - [x] 缺点

    - 依赖有序数据
    - 二次查询，先查索引，再根据索引查数据

### 非聚簇索引一定回表查询吗(覆盖索引)?

!!! tip "非聚簇索引一定回表查询吗(覆盖索引)?"

    不一定，如果索引本身就是要查的值，就不需要回表查了，比如查主键id

### 覆盖索引

!!! tip "覆盖索引"

    索引包含（或者说覆盖）所有需要查询的字段的值

### 联合索引

!!! tip "联合索引"

    使用表中的多个字段创建索引，就是 联合索引，也叫 组合索引 或 复合索引

### 最左前缀匹配原则

!!! tip "最左前缀匹配原则"

    根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配

    `<` `>` 会停止匹配，`>=`、`<=`、`BETWEEN`、`like`可以匹配

### 正确使用索引的一些建议

!!! tip "正确使用索引的一些建议"


    - 字段的数据应该尽量不为 NULL，如果需要可以用0,1,false做语义代替
    - 被频繁查询的字段
    - 被作为条件查询的字段
    - 频繁需要排序的字段
    - 被经常频繁用于连接的字段
    - 被频繁更新的慎重用
    - 限制每张表上的索引数量,建议不超过5个
    - 尽可能的考虑建立联合索引
    - 注意避免冗余索引
    - 避免索引失效,未遵守最左匹配、索引上有计算、函数、模糊查询左匹配`like '%abc'`、or前后有一个没使用索引
    - 删除长期未使用索引
    - 直到用explain执行器判断是否走索引

### MySQL三大日志(binlog、redo log和undo log)详解

!!! tip "MySQL三大日志(binlog、redo log和undo log)详解"

    - [x] redo log

    InnoDB独有,崩溃恢复

    - [x] binlog

    记录数据更新

    事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。

    - [x] undo log

    来保证事务的原子性，用来做数据回滚


### 事务隔离级别

!!! tip "事务隔离级别"

    - [x] READ-UNCOMMITTED(读取未提交)

    可能会导致脏读、幻读或不可重复读

    - [x] READ-COMMITTED(读取已提交)

    可以阻止脏读，但是幻读或不可重复读仍有可能发生。

    - [x] REPEATABLE-READ(可重复读)

    可以阻止脏读和不可重复读，但幻读仍有可能发生。

    - [x] SERIALIZABLE(可串行化)

    可以防止脏读、不可重复读以及幻读


### InnoDB 实现的 REPEATABLE-READ 隔离级别为什么可以解决幻读问题

!!! tip "InnoDB 实现的 REPEATABLE-READ 隔离级别为什么可以解决幻读问题"

    - 由 MVCC 机制来保证不出现幻读。
    - 行锁锁住当前行+间隙锁避免插入新行

### SQL语句在MySQL中的执行过程

!!! tip "SQL语句在MySQL中的执行过程"

    - [x] 查询语句

    1. 先检查该语句是否有权限
    2. 查询缓存(mysql8之前)
    3. 通过分析器进行词法分析
    4. 优化器优化
    5. 调用数据库引擎接口，返回引擎的执行结果。

    - [x] 更新语句

    1. 先查询
    2. 把查询的数据修改，然后调用引擎写入数据。同时记录redo log进行准备状态
    3. 执行器记录binlog，redo log为提交状态，更新完成

### 什么是执行计划？

!!! tip "什么是执行计划？"

    SQL 语句在经过 MySQL 查询优化器 的优化会后，具体的执行方式。

### 如何分析 EXPLAIN 结果？

!!! tip "如何分析 EXPLAIN 结果？"

    - [x] select_type

    - SIMPLE：简单查询
    - PRIMARY：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。
    - SUBQUERY：子查询中的第一个 SELECT。
    - UNION：在 UNION 语句中，UNION 之后出现的 SELECT。
    - DERIVED：在 FROM 中出现的子查询将被标记为 DERIVED。
    - UNION RESULT：UNION 查询的结果。


    - [x] type

    从最优到最差排序为：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

    - const：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。
    - eq_ref：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。
    - ref：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。
    - index_merge：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。
    - range：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。
    - index：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。
    - ALL：全表扫描。


    - [x] possible_keys:可能用到的索引,如果为 NULL，则表示未用到索引

    - [x] key:实际使用到的索引。如果为 NULL，则表示未用到索引

    - [x] Extra

    - Using filesort：在排序时使用了外部的索引排序，没有用到表内索引进行排序。
    - Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。
    - Using index：表明查询使用了覆盖索引，不用回表，查询效率非常高。
    - Using index condition：表示查询优化器选择使用了索引条件下推这个特性。
    - Using where：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。
    - Using join buffer (Block Nested Loop)：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。


### MySQL自增主键一定是连续的吗

!!! tip "MySQL自增主键一定是连续的吗"

    - 自增初始值和自增步长设置不为 1
    - 唯一键冲突
    - 事务回滚
    - 批量插入（如 insert...select 语句） 多次申请，申请多的也不回退


### MySQL时间类型数据存储建议

!!! tip "MySQL时间类型数据存储建议"

    - 不要用字符串存储日期:占用的空间更大,无法用日期相关的 API 进行计算和比较
    - Datetime 和 Timestamp 之间抉择:通常我们都会首选 Timestamp,DateTime 类型是没有时区信息的,DateTime 类型耗费空间更大
    - 数值型时间戳，效率高又兼容，但是不直观

### MySQL隐式转换造成索引失效

!!! tip "MySQL隐式转换造成索引失效"

    当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成隐式转换进而索引失效触发全表扫描