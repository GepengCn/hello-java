# 并发

## 问题

- 什么是指令重排序
- 什么是主内存？什么是本地内存？
- happens-before 原则是什么？为什么需要 happens-before 原则？happens-before 常见规则有哪些？谈谈你的理解？
- 并发编程三个重要特性
- 如何保证变量的可见性？
- 如何禁止指令重排序？
- volatile 可以保证原子性么?
- 乐观锁和悲观锁
- 如何实现乐观锁？
- 乐观锁存在哪些问题？
- synchronized 是什么？有什么用？
- 如何使用 synchronized？
- 构造方法可以用 synchronized 修饰么？
- synchronized 底层原理了解吗？
- JDK1.6 之后的 synchronized 底层做了哪些优化？
- synchronized 和 volatile 有什么区别？
- ReentrantLock 是什么？
- 公平锁和非公平锁有什么区别？
- synchronized 和 ReentrantLock 有什么区别？
- 可中断锁和不可中断锁有什么区别？
- ReentrantReadWriteLock 是什么？
- ReentrantReadWriteLock 适合什么场景？
- 共享锁和独占锁有什么区别？
- 线程持有读锁还能获取写锁吗？
- 读锁为什么不能升级为写锁？
- Atomic 原子类介绍，有哪几种类型，分别介绍一下?
- 基本数据类型原子类的优势
- AtomicInteger 线程安全原理简单分析
- ThreadLocal 有什么用？
- 如何使用 ThreadLocal？
- ThreadLocal 原理了解吗？
- ThreadLocal 内存泄露问题是怎么导致的？
- 什么是线程池?为什么要用线程池？如何创建线程池？
- 为什么不推荐使用内置线程池？
- 线程池常见参数有哪些？如何解释？
- 线程池的饱和策略有哪些？
- 线程池常用的阻塞队列有哪些？
- 线程池处理任务的流程了解吗？
- 如何给线程池命名？
- 如何设定线程池的大小？
- 如何动态修改线程池的参数？
- Future 类有什么用？
- Callable 和 Future 有什么关系？
- CompletableFuture 类有什么用？
- AQS 是什么？
- AQS 的原理是什么？
- Semaphore 有什么用？
- Semaphore 的原理是什么？
- CountDownLatch 有什么用？
- CountDownLatch 的原理是什么？
- 用过 CountDownLatch 么？什么场景下用的？
- CyclicBarrier 有什么用？
- CyclicBarrier 的原理是什么？

!!! tip "什么是指令重排序"

    简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。

    常见的指令重排序有下面 2 种情况：

    - 编译器优化重排：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。

    - 指令并行重排：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。


!!! tip "什么是主内存？什么是本地内存？"

    - 主内存：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)

    - 本地内存：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。

!!! tip "happens-before 原则是什么？为什么需要 happens-before 原则？happens-before 常见规则有哪些？谈谈你的理解？"

    1. 在分布式环境中，通过一系列规则来定义逻辑时钟的变化，从而能通过逻辑时钟来对分布式系统中的事件的先后顺序进行判断。逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。

    2. happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。happens-before 原则的设计思想其实非常简单：
    - 为了对编译器和处理器的约束尽可能少，只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。
    - 对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。



    3. 5条规则
    - 程序顺序规则：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；
    - 解锁规则：解锁 happens-before 于加锁；
    - volatile 变量规则：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。
    - 传递规则：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；
    - 线程启动规则：Thread 对象的 start()方法 happens-before 于此线程的每一个动作。

!!! tip "并发编程三个重要特性"

    ## 1. 原子性

    一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。

    在 Java 中，可以借助synchronized、各种 Lock 以及各种原子类实现原子性。synchronized 和各种 Lock 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 volatile或者final关键字）来保证原子操作。

    ## 2. 可见性

    当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。在 Java 中，可以借助synchronized、volatile 以及各种 Lock 实现可见性。如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

    ## 3. 有序性

    由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。

    我们上面讲重排序的时候也提到过：

    > 指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。

    在 Java 中，volatile 关键字可以禁止指令进行重排序优化。

!!! tip "如何保证变量的可见性？"

    在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

    volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。

!!! tip "如何禁止指令重排序？"

    在 Java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。


!!! tip "volatile 可以保证原子性么?"

    volatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。

!!! tip "乐观锁和悲观锁"

    ## 什么是悲观锁？

    悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。

    像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

    ## 什么是乐观锁？
    乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。

    在 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式 CAS 实现的。
    高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。

    理论上来说：

    - 悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。
    - 乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考java.util.concurrent.atomic包下面的原子变量类）。#


!!! tip "如何实现乐观锁？"

    乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意

    1. 版本号机制

    一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。

    2. CAS 算法

    CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。

    CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。

    CAS 涉及到三个操作数：

    - V：要更新的变量值(Var)
    - E：预期值(Expected)
    - N：拟写入的新值(New)

    当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。

!!! tip "乐观锁存在哪些问题？"

    1. ABA 问题是乐观锁最常见的问题。

    如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 "ABA"问题。

    ABA 问题的解决思路是在变量前面追加上版本号或者时间戳。JDK 1.5 以后的 AtomicStampedReference 类就是用来解决 ABA 问题的，其中的 compareAndSet() 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

    2. 循环时间长开销大

    CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。

    3. 只能保证一个共享变量的原子操作

    CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

!!! tip "synchronized 是什么？有什么用？"

    synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

    在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。

    不过，在 Java 6 之后， synchronized 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 synchronized 锁的效率提升了很多。因此， synchronized 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 synchronized 。

!!! tip "如何使用 synchronized？"

    synchronized 关键字的使用方式主要有下面 3 种：

    1. 修饰实例方法（锁当前对象实例）:给当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁 。
    2. 修饰静态方法（锁当前类）:给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。
    3. 修饰代码块（锁指定对象/类）:对括号里指定的对象/类加锁

        - synchronized(object) 表示进入同步代码库前要获得 给定对象的锁。
        - synchronized(类.class) 表示进入同步代码前要获得 给定 Class 的锁

!!! tip "构造方法可以用 synchronized 修饰么？"

    构造方法不能使用 synchronized 关键字修饰。

    构造方法本身就属于线程安全的，不存在同步的构造方法一说。

!!! tip "synchronized 底层原理了解吗？"

    synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。

    synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。

    不过两者的本质都是对对象监视器 monitor 的获取。

!!! tip "JDK1.6 之后的 synchronized 底层做了哪些优化？"

    JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

    锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

!!! tip "synchronized 和 volatile 有什么区别？"

    synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！

    - volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。
    - volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。
    - volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。


!!! tip "ReentrantLock 是什么？"

    ReentrantLock 实现了 Lock 接口，是一个可重入且独占式的锁，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。

    ReentrantLock 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。

!!! tip "公平锁和非公平锁有什么区别？"

    - 公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。
    - 非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。

!!! tip "synchronized 和 ReentrantLock 有什么区别？"

    ## 1. 两者都是可重入锁

    可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。

    JDK 提供的所有现成的 Lock 实现类，包括 synchronized 关键字锁都是可重入的。

    ## 2. synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

    synchronized 是依赖于 JVM 实现的，虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。

    ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。


    ## 3. ReentrantLock 比 synchronized 增加了一些高级功能

    主要来说主要有三点：

    - 等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
    - 可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来指定是否是公平的。
    - 可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。但是通知的线程对象是不可选择的，是由JVM选择的，而ReentrantLock的Condition实例可选择性通知，灵活性更高。


!!! tip "可中断锁和不可中断锁有什么区别？"

    - 可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。
    - 不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁。#

!!! tip "ReentrantReadWriteLock 是什么？"

    ReentrantReadWriteLock 在实际项目中使用的并不多，面试中也问的比较少，简单了解即可。JDK 1.8 引入了性能更好的读写锁 StampedLock 。

    ReentrantReadWriteLock 实现了 ReadWriteLock ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。

    ReentrantReadWriteLock 其实是两把锁，一把是 WriteLock (写锁)，一把是 ReadLock（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。

    - 一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。
    - 读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。

    ReentrantReadWriteLock 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。

!!! tip "ReentrantReadWriteLock 适合什么场景？"

    由于 ReentrantReadWriteLock 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 ReentrantReadWriteLock 能够明显提升系统性能。

!!! tip "共享锁和独占锁有什么区别？"

    - 共享锁：一把锁可以被多个线程同时获得。
    - 独占锁：一把锁只能被一个线程获得。

!!! tip "线程持有读锁还能获取写锁吗？"

    - 在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。
    - 在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。

!!! tip "读锁为什么不能升级为写锁？"

    写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。

    另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。

!!! tip "Atomic 原子类介绍，有哪几种类型，分别介绍一下?"

    1. 基本类型

        - AtomicInteger
        - AtomicLong
        - AtomicBoolean

    2. 数组类型

        - AtomicIntegerArray
        - AtomicLongArray
        - AtomicReferenceArray

    3. 引用类型

        - AtomicReference: 引用类型原子类
        - AtomicMarkableReference:原子更新带有标记的引用类型
        - AtomicStampedReference:原子更新带有版本号的引用类型。可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

    4. 对象的属性修改类型

        - AtomicIntegerFieldUpdater: 原子更新整型字段的更新器
        - AtomicLongFieldUpdater: 原子更新长整型字段的更新器
        - AtomicReferenceFieldUpdater: 原子更新引用类型里的字段