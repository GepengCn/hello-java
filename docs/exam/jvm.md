# Java 内存区域详解 JVM

## 问题

- 运行时数据区域概述
- 程序计数器
- Java 虚拟机栈
- 程序运行中栈可能会出现的错误
- 本地方法栈
- 堆
- 堆可能出现的错误
- 方法区
- 方法区和永久代以及元空间是什么关系呢？
- 为什么要将永久代替换为元空间呢?
- 运行时常量池
- 字符串常量池
- JDK 1.7 为什么要将字符串常量池移动到堆中？
- 直接内存
- 直接内存怎么在java中应用的
- Java 对象的创建过程
- 内存分配的两种方式
- 内存分配并发问题
- 对象的内存布局
- 对象的访问定位
- 内存分配和回收原则
- 主要进行 gc 的区域
- 空间分配担保
- 死亡对象判断方法
- 哪些对象可以作为 GC Roots 呢？
- 对象可以被回收，就代表一定会被回收吗？
- 引用类型有哪些
- 如何判断一个类是无用的类？
- 垃圾收集算法有哪些？
- 垃圾收集器有哪些？
- 类加载器介绍
- 双亲委派模型介绍
- 双亲委派模型的执行流程
- 双亲委派模型的好处
- 打破双亲委派模型方法
- 显式指定堆内存
- 显式新生代内存
- 显式指定永久代/元空间的大小
- 指定垃圾回收垃圾器
- GC 日志记录
- 处理 OOM 配置
- 查看所有 Java 进程
- 监视虚拟机各种运行状态信息
- 实时地查看和调整虚拟机各项参数
- 生成堆转储快照
- 分析 heapdump 文件
- 生成虚拟机当前时刻的线程快照
- JVM线上问题排查和性能调优案例


## 答案
### 运行时数据区域概述

!!! tip "运行时数据区域概述"

    jdk1.8之前

    - 线程共享：堆、方法区、运行时常量池
    - 线程私有：虚拟机栈、本地方法栈、程序计数器
    - 本地内存：直接内存

    jdk1.8及之后

    - 线程共享：堆
    - 线程私有：虚拟机栈、本地方法栈、程序计数器
    - 本地内存：直接内存、元空间（方法区、运行时常量池）


### 程序计数器

!!! tip "程序计数器"

    当前线程所执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取要执行的指令，比如分支、循环、跳转、异常处理、线程恢复都需要依赖这个计数器来完成。

### Java 虚拟机栈

!!! tip "Java 虚拟机栈"

    线程私有的，它的生命周期和线程相同，随着线程生而生，死而死。

    所有的`Java` 方法调用都是通过虚拟机栈实现，每次方法调用都会有一个栈帧压入栈，方法结束，栈帧被弹出。

    每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。

    - **局部变量表**:存放了编译期可知的各种数据类型、对象引用
    - **操作数栈**:存放方法执行过程中产生的中间计算结果和临时变量。
    - **动态链接**:将符号引用转换为调用方法的直接引用 。
    - **方法返回地址**:一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。


### 程序运行中栈可能会出现的错误

!!! tip "程序运行中栈可能会出现的错误"

    - StackOverFlowError： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

    - OutOfMemoryError： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

### 本地方法栈

!!! tip "本地方法栈"

    和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。


### 堆

!!! tip "堆"

    Java 虚拟机所管理的内存中最大的一块，所有线程共享的一块内存区域，在虚拟机启动时创建。**唯一目的就是存放对象实例**

    垃圾收集器管理的主要区域，因此也被称作 GC 堆。

### 堆可能出现的错误

!!! tip "堆可能出现的错误"

    - `java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`:当jvm花太多时间执行垃圾回收但能回收很小的堆空间时
    - `java.lang.OutOfMemoryError: Java heap space`:创建对象时，堆剩余空间不足以存放的时候
### 方法区

!!! tip "方法区"

    存储已被虚拟机加载的 类、字段、方法信息和常量、静态变量、编译后的代码缓存等数据。


### 方法区和永久代以及元空间是什么关系呢？

!!! tip "方法区和永久代以及元空间是什么关系呢？"

    很像 Java 中接口和类的关系，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。


### 为什么要将永久代替换为元空间呢?

!!! tip "为什么要将永久代替换为元空间呢?"

    永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。


### 运行时常量池

!!! tip "运行时常量池"

    用于存放编译期生成的各种字面量和符号引用。

### 字符串常量池

!!! tip "字符串常量池"

    为了提升性能和减少内存消耗专门开辟的一块区域，主要目的是避免字符串的重复创建。

    JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 从永久代移动了 Java 堆中。

### JDK 1.7 为什么要将字符串常量池移动到堆中？

!!! tip "JDK 1.7 为什么要将字符串常量池移动到堆中？"

    因为永久代的 GC 回收效率太低，只有在Full GC的时候才会被回收。

### 直接内存

!!! tip "直接内存"

    不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。

### 直接内存怎么在java中应用的

!!! tip "直接内存怎么在java中应用的"

    NIO，一种基于通道与缓冲区的 I/O 方式，通过JNI可以直接分配堆外内存，然后通过DirectByteBuffer引用这块内存。在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

### Java 对象的创建过程

!!! tip "Java 对象的创建过程或者类的生命周期"

    在Java中，对象的创建是一个多步骤过程，涉及到内存的分配、初始化等多个阶段。这个过程主要通过`new`关键字在Java虚拟机（JVM）中实现。以下是Java对象创建的基本步骤：

    ### 1. 类加载检查

    当代码中出现`new`关键字时，JVM首先会检查这个指令的参数（即要创建的对象的类），看是否已经被加载、链接和初始化过。如果没有，那么必须先执行相应的类加载过程。

    ### 2. 分配内存

    一旦类检查通过，接下来JVM为新对象分配内存。内存的分配方式主要有两种：

    - **指针碰撞（Bump the Pointer）**：如果Java堆内存是绝对规整的，所有用过的内存放在一边，空闲的内存放在另一边，那么分配内存就是简单地将指针向空闲空间挪动对象大小的距离。

    - **空闲列表（Free List）**：如果Java堆内存中存在不连续的空闲内存，JVM就需要通过维护一个列表来记录可用的内存，分配时从这个列表中找到足够大的空间分配给对象。

    内存分配过程中还可能涉及到线程安全问题，JVM可以通过两种方式来处理：

    - **同步处理**：如采用CAS加失败重试的方式保证更新操作的原子性。
    - **本地线程分配缓冲（TLAB）**：为每个线程预分配一小块内存，这样每个线程在自己的TLAB上分配内存就不需要同步了。

    ### 3. 初始化零值

    内存分配完成后，JVM会将分配的内存空间都初始化为零值（不包括对象头），这确保了对象的属性在Java代码中可以不赋初始值就直接使用。

    ### 4. 设置对象头

    JVM需要把对象是哪个类的实例的信息、对象的哈希码、对象的GC分代年龄等信息写入对象头中。

    ### 5. 执行<init>方法

    最后，JVM会调用构造函数，即执行<init>方法。这个方法中不仅包含了编程人员编写的代码逻辑，还可能调用父类构造器等，完成对象的构造。

    ### 总结

    Java对象的创建是一个从类加载检查到分配内存，再到初始化零值、设置对象头，最后执行构造函数的过程。每一步都是为了确保对象能够正确且高效地被创建和使用。了解这一过程有助于深入理解Java的内存管理和对象生命周期。

### 内存分配的两种方式(可选)

!!! tip "内存分配的两种方式"

    - 指针碰撞：
        - 适用场合：堆内存规整。
        - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，分配内存时，向没用过的区域移动指针。
        - GC 收集器：Serial, ParNew
    - 空闲列表：
        - 适用场合：堆内存不规整。
        - 原理：虚拟机会维护一个列表，记录哪些内存块是可用的，分配内存时，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
        - GC 收集器：CMS

### 内存分配并发问题(可选)

!!! tip "内存分配并发问题"

    - CAS+失败重试
    - TLAB:为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当大于 TLAB 中的剩余内存，再采用上述的 CAS 进行内存分配

    什么事TLAB https://blog.csdn.net/hfer/article/details/106077631

### 对象的内存布局(可选)

!!! tip "对象的内存布局"

    分为 3 块区域：对象头、实例数据和对齐填充。

    对象头：包括两部分信息，一部分用于存储哈希码、GC 分代年龄、锁状态标志，另一部分是类型指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

    实例数据:程序中定义的各种类型的字段内容。

    对齐填充：不是必然存在的，仅仅起占位作用。虚拟机的要求对象起始地址必须是 8 字节的整数倍，因此，当没有对齐时，就需要对齐填充来补全。


### 对象的访问定位(可选)

!!! tip "对象的访问定位"

    目前主流的访问方式有：使用句柄、直接指针。

    - [x] 句柄

        堆中将会划分出一块内存来作为句柄池，reference引用中存储的就是对象的句柄地址，而句柄中包含了对象实例与它的类型的具体地址信息。

    - [x] 直接指针

        如果使用直接指针访问，reference 中存储的直接就是对象的地址。

    HotSpot 虚拟机主要使用的就是**直接指针**方式来进行对象访问。

### 内存分配和回收原则

!!! tip "内存分配和回收原则"

    在Java中，内存分配和回收是自动管理的，主要依赖于垃圾收集器（Garbage Collector, GC）的工作机制。理解Java内存分配和回收的原则对于编写高效、可靠的Java应用程序至关重要。

    ### 内存分配原则

    1. **对象优先在Eden区分配**：Java堆内存被分为新生代和老年代，新生代又分为一个Eden区和两个Survivor区（通常称为From和To）。大多数情况下，对象首先在Eden区分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

    2. **大对象直接进入老年代**：所谓的大对象是指需要大量连续内存空间的Java对象，比如很长的字符串及数组。大对象直接进入老年代，避免在Eden区及两个Survivor区之间发生大量的内存复制。

    3. **长期存活的对象将进入老年代**：对象在Survivor区中熬过一定数量的GC后，如果还没有被回收，就会被移动到老年代中。这个年龄阈值可以通过参数`-XX:MaxTenuringThreshold`来设置。

    4. **动态对象年龄判定**：为了更好地适应不同程序的内存情况，虚拟机并不是永远要求对象的年龄必须达到`MaxTenuringThreshold`才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到`MaxTenuringThreshold`中要求的年龄。

    ### 内存回收原则

    1. **引用计数法**：这是最基础的垃圾收集算法，给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1。任何时刻计数器为0的对象就是不可能再被使用的。但是主流Java虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间相互循环引用的问题。

    2. **可达性分析算法**：这是当前主流的Java虚拟机使用的垃圾收集算法。通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

    3. **分代收集算法**：Java堆分为新生代和老年代，这种算法根据各个年龄段的特点采用最适当的收集算法。比如，在新生代中，每次垃圾收集时都有大量对象死去，只有少量存活，就选择复制算法，只需要复制少量存活的对象就可以了。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用"标记-清理"或"标记-整理"算法来进行回收。

    通过这些原则，Java虚拟机（JVM）能够高效地对内存进行分配和回收，从而管理运行在其上的Java应用程序的内存。了解这些原则有助于开发者编写更高效的Java代码，特别是在处理大量数据和执行长时间运行的应用程序时。

### 死亡对象判断方法

!!! tip "死亡对象判断方法"

    - [x] 引用计数法

    很难解决对象之间循环引用的问题。

    - [x] 可达性分析算法

    通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，证明此对象是不可用，需要被回收。

### 哪些对象可以作为 GC Roots 呢？

!!! tip "哪些对象可以作为 GC Roots 呢？"

    - 虚拟机栈(栈帧中的本地变量表)中引用的对象
    - 本地方法栈(Native 方法)中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 被同步锁持有的对象

### 对象可以被回收，就代表一定会被回收吗？

!!! tip "对象可以被回收，就代表一定会被回收吗？"

    不会马上被回收，还需要进行两次标记。

    - 第一次标记：判断当前对象是否有 finalize() 方法，若不存在则标记为垃圾对象，等待回收；若有的话，并且该方法没有被执行，则进行第二次标记；

    - 第二次标记将当前对象放入 F-Queue 队列，并生成一个线程去执行finalize方法，
如果执行了 finalize() 方法之后仍然没有与 GC Roots 有直接或者间接的引用，则该对象会被回收。



### 引用类型有哪些

!!! tip "引用类型有哪些"

    - [x] 强引用

    垃圾回收器绝不会回收它。

    - [x] 软引用

    只有内存空间不足了，才回收这些对象的内存
    - [x] 弱引用


    只要垃圾回收器发现它，就会回收

    - [x] 虚引用

    在任何时候都可能被垃圾回收。 **虚引用主要用来跟踪对象被垃圾回收的活动。**


### 如何判断一个类是无用的类？

!!! tip "如何判断一个类是无用的类？"

    - 该类所有的实例都已经被回收
    - 加载该类的 ClassLoader 已经被回收。
    - 该类没有在任何地方被引用，无法通过反射访问该类的方法。

### 垃圾收集算法有哪些？

!!! tip "垃圾收集算法有哪些？"

    - [x] 标记-清除算法

    首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

    - 产生不连续的内存碎片。

    - [x] 复制算法

    它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。

    - 可用内存变小：可用内存缩小为原来的一半。
    - 不适合老年代：如果存活对象数量比较大，复制性能会变得很差。
    
    - [x] 标记-整理算法

    标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

    由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。

    - [x] 分代收集算法

    根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代

    比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。

    而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。


### 垃圾收集器有哪些？

!!! tip "垃圾收集器有哪些？"

    Java虚拟机（JVM）提供了多种垃圾收集器，每种收集器都有其特定的使用场景和优化目标。不同收集器之间的主要区别在于它们的工作方式、回收数据的时间点以及它们对系统资源的占用。截至Java 11，以下是一些主流的垃圾收集器及其特点：

    ### 1. Serial收集器

    - **类型**：单线程收集器。
    - **工作模式**：使用标记-压缩算法。
    - **特点**：简单高效（对于单核处理器或小内存环境），在进行垃圾收集时需要暂停所有工作线程（Stop-The-World）。
    - **适用场景**：适合单核处理器环境或小内存Java应用。

    ### 2. Parallel（并行）收集器

    - **类型**：多线程收集器。
    - **工作模式**：使用标记-压缩算法。
    - **特点**：多线程执行垃圾回收，提高了垃圾收集时的效率，但在垃圾收集时也需要暂停所有工作线程。
    - **适用场景**：适合多核服务器，重视吞吐量以及CPU资源利用率的应用。

    ### 3. CMS（Concurrent Mark Sweep）收集器

    - **类型**：并发收集器。
    - **工作模式**：使用标记-清除算法。
    - **特点**：并发收集、低停顿。分为几个阶段，其中标记和清除阶段的大部分工作与应用线程并发执行。
    - **适用场景**：适合响应时间有严格要求的应用，比如Web服务器。

    ### 4. G1（Garbage-First）收集器

    - **类型**：并发收集器。
    - **工作模式**：将堆内存划分为多个区域（Region），通过优先回收价值最大的区域来优化垃圾收集性能。
    - **特点**：并发执行、分代收集、可预测的停顿时间。
    - **适用场景**：面向服务端应用，尤其是多核处理器和大内存环境，需要平衡吞吐量与停顿时间。

    ### 5. ZGC（Z Garbage Collector）和Shenandoah收集器

    - **类型**：低延迟收集器。
    - **工作模式**：两者都采用了先进的技术来实现几乎全部工作的并发执行，减少停顿时间到毫秒级别。
    - **特点**：极低的停顿时间，适合延迟敏感型应用。
    - **适用场景**：适合需要极低停顿时间的大型应用，比如实时系统、大型游戏服务器等。

    这些垃圾收集器各有优劣，适用于不同的应用场景。选择哪个垃圾收集器主要取决于应用的需求、硬件环境以及性能目标。随着Java版本的更新，可能会引入新的垃圾收集器或对现有收集器进行改进，因此建议关注最新的Java版本信息。

### 类加载器介绍

!!! tip "类加载器介绍"

    在Java中，类加载器（ClassLoader）是用于加载Java类到JVM中的一部分。Java虚拟机采用委派模型来加载类，这意味着类加载器会尝试让其父类加载器先尝试加载类，以此来保证Java平台的核心类不会被覆盖。在Java中，主要有以下几种类型的类加载器：

    ### 1. 引导类加载器（Bootstrap ClassLoader）

    - **职责**：加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。引导类加载器是用原生代码实现的，并不继承自java.lang.ClassLoader。
    - **特点**：它不是Java类，而是由JVM实现的。

    ### 2. 扩展类加载器（Extension ClassLoader）

    - **职责**：加载JRE的扩展目录（JAVA_HOME/jre/lib/ext或java.ext.dirs系统属性指定的目录）中的类库。
    - **实现**：由sun.misc.Launcher$ExtClassLoader实现。

    ### 3. 系统（应用）类加载器（System/Application ClassLoader）

    - **职责**：加载系统类路径（ClassPath，即环境变量classpath或系统属性java.class.path指定的目录）下的类库，通常是我们开发的那部分Java程序代码。
    - **实现**：由sun.misc.Launcher$AppClassLoader实现。

    ### 类加载机制

    Java类加载器的工作机制包括三个主要步骤：加载、链接（验证、准备、解析）、初始化。

    - **加载**：查找并加载类的二进制数据。
    - **链接**：
      - **验证**：确保被加载类的正确性。
      - **准备**：为类的静态变量分配内存，并将其初始化为默认值。
      - **解析**：把类中的符号引用转换为直接引用。
    - **初始化**：对类的静态变量按照程序中的指定的初始化值进行初始化，执行静态代码块。

    ### 自定义类加载器

    在某些情况下，标准的类加载器可能无法满足特定的需求。例如，从网络或其他非标准来源加载类。在这些情况下，可以通过继承`java.lang.ClassLoader`类来创建自定义类加载器。

    ### 类加载器的重要性

    类加载器在Java安全模型中扮演着重要的角色，它确保了Java应用的安全性和动态性。通过类加载器，Java能够动态加载类，支持热部署和热替换，同时保证了运行时环境的隔离（不同的类加载器可以加载相同名称的类而互不干扰）。


### 双亲委派模型介绍

!!! tip "双亲委派模型介绍"

    - ClassLoader 类使用委托模型来搜索类和资源。
    - 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
    - ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

### 双亲委派模型的执行流程

!!! tip "双亲委派模型的执行流程"

    - 先判断类是否被加载过。已加载会直接返回，否则才会尝试加载
    - 首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成
    - 只有当父加载器无法加载时，子加载器才会自己去加载

### 双亲委派模型的好处

!!! tip "双亲委派模型的好处"

    - 保证了Java程序的稳定
    - 避免类的重复加载
    - 保证了核心API不被篡改

### 打破双亲委派模型方法

!!! tip "打破双亲委派模型方法"

    需要重写 loadClass() 方法

### 显式指定堆内存

!!! tip "显式指定堆内存"

    ```powershell
    -Xms2G //最小堆
    -Xmx5G //最大最
    ```

### 显式新生代内存
!!! tip "显式新生代内存"

    ```powershell
    第一种
    -XX:NewSize=256m //新生代分配 最小 256m 的内存
    -XX:MaxNewSize=1024m //新生代分配 最大 1024m
    第二种
    -Xmn256m //NewSize 与 MaxNewSize 设为一致
    ```


### 显式指定永久代/元空间的大小
!!! tip "显式指定永久代/元空间的大小"

    ```powershell
    -XX:MetaspaceSize=N //MetaspaceSize 表示 Metaspace 使用过程中触发 Full GC 的阈值，只对触发起作用。
    -XX:MaxMetaspaceSize=N #设置 Metaspace 的最大大小
    ```

### 指定垃圾回收垃圾器
!!! tip "指定垃圾回收垃圾器"

    ```powershell
    -XX:+UseSerialGC
    -XX:+UseParallelGC
    -XX:+UseParNewGC
    -XX:+UseG1GC
    ```

### GC 日志记录
!!! tip "GC 日志记录"

    ```powershell
    # 必选
    # 打印基本 GC 信息
    -XX:+PrintGCDetails
    -XX:+PrintGCDateStamps
    # 打印对象分布
    -XX:+PrintTenuringDistribution
    # 打印堆数据
    -XX:+PrintHeapAtGC
    # 打印Reference处理信息
    # 强引用/弱引用/软引用/虚引用/finalize 相关的方法
    -XX:+PrintReferenceGC
    # 打印STW时间
    -XX:+PrintGCApplicationStoppedTime

    # GC日志输出的文件路径
    -Xloggc:/path/to/gc-%t.log
    # 开启日志文件分割
    -XX:+UseGCLogFileRotation
    # 最多分割几个文件，超过之后从头文件开始写
    -XX:NumberOfGCLogFiles=14
    # 每个文件上限大小，超过就触发分割
    -XX:GCLogFileSize=50M
    ```

### 处理 OOM 配置
!!! tip "处理 OOM 配置"

    ```powershell
    -XX:+HeapDumpOnOutOfMemoryError
    -XX:HeapDumpPath=./java_pid<pid>.hprof
    -XX:OnOutOfMemoryError="< cmd args >;< cmd args >"
    -XX:+UseGCOverheadLimit
    ```

    - HeapDumpOnOutOfMemoryError 指示 JVM 在遇到 OutOfMemoryError 错误时将 heap 转储到物理文件中。
    - HeapDumpPath 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 <pid> 标记，则当前进程的进程 id 将附加到文件名中，并使用.hprof格式
    - OnOutOfMemoryError 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 cmd args 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: -XX:OnOutOfMemoryError="shutdown -r" 。
    - UseGCOverheadLimit 是一种策略，它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例#

### 查看所有 Java 进程
!!! tip "查看所有 Java 进程"

    ```powershell
    jps #显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID
    jps -q #只输出进程的本地虚拟机唯一 ID。
    jps -l #输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。
    jps -v #输出虚拟机进程启动时 JVM 参数。
    jps -m #输出传递给 Java 进程 main() 函数的参数。
    ```

### 监视虚拟机各种运行状态信息
!!! tip "监视虚拟机各种运行状态信息"

    ```powershell
    jstat -gc -h3 31736 1000 10   #表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。
    ```

    - jstat -class vmid：显示 ClassLoader 的相关信息；
    - jstat -compiler vmid：显示 JIT 编译的相关信息；
    - jstat -gc vmid：显示与 GC 相关的堆信息；
    - jstat -gccapacity vmid：显示各个代的容量及使用情况；
    - jstat -gcnew vmid：显示新生代信息；
    - jstat -gcnewcapcacity vmid：显示新生代大小与使用情况；
    - jstat -gcold vmid：显示老年代和永久代的行为统计，从 jdk1.8 开始,该选项仅表示老年代，因为永久代被移除了；
    - jstat -gcoldcapacity vmid：显示老年代的大小；
    - jstat -gcutil vmid：显示垃圾收集信息；

### 实时地查看和调整虚拟机各项参数
!!! tip "实时地查看和调整虚拟机各项参数"

    jinfo vmid :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。

    jinfo -flag name vmid :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( -XX:PrintGCDetails :详细 GC 日志模式，这两个都是默认关闭的)。

    ```powershell
    C:\Users\SnailClimb>jinfo  -flag MaxHeapSize 17340
    -XX:MaxHeapSize=2124414976
    C:\Users\SnailClimb>jinfo  -flag PrintGC 17340
    -XX:-PrintGC
    ```

    使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：

    jinfo -flag [+|-]name vmid 开启或者关闭对应名称的参数。

    ```powershell
    C:\Users\SnailClimb>jinfo  -flag  PrintGC 17340
    -XX:-PrintGC

    C:\Users\SnailClimb>jinfo  -flag  +PrintGC 17340

    C:\Users\SnailClimb>jinfo  -flag  PrintGC 17340
    -XX:+PrintGC
    ```

### 生成堆转储快照
!!! tip "生成堆转储快照"

    jmap（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 jmap 命令，要想获取 Java 堆转储，可以使用 “-XX:+HeapDumpOnOutOfMemoryError” 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 kill -3 发送进程退出信号也能拿到 dump 文件。

    jmap 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和jinfo一样，jmap有不少功能在 Windows 平台下也是受限制的。

    示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。

    ```powershell
    C:\Users\SnailClimb>jmap -dump:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof 17340
    Dumping heap to C:\Users\SnailClimb\Desktop\heap.hprof ...
    Heap dump file created
    ```

### 分析 heapdump 文件
!!! tip "分析 heapdump 文件"

    jhat 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。

    ```powershell
    C:\Users\SnailClimb>jhat C:\Users\SnailClimb\Desktop\heap.hprof
    Reading from C:\Users\SnailClimb\Desktop\heap.hprof...
    Dump file created Sat May 04 12:30:31 CST 2019
    Snapshot read, resolving...
    Resolving 131419 objects...
    Chasing references, expect 26 dots..........................
    Eliminating duplicate references..........................
    Snapshot resolved.
    Started HTTP server on port 7000
    Server is ready.
    ```

### 生成虚拟机当前时刻的线程快照
!!! tip "生成虚拟机当前时刻的线程快照"

    jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.

    生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。

    ```powershell
    C:\Users\SnailClimb>jps
    13792 KotlinCompileDaemon
    7360 NettyClient2
    17396
    7972 Launcher
    8932 Launcher
    9256 DeadLockDemo
    10764 Jps
    17340 NettyServer

    C:\Users\SnailClimb>jstack 9256

    ```

### JVM线上问题排查和性能调优案例
!!! tip "JVM线上问题排查和性能调优案例"

    https://javaguide.cn/java/jvm/jvm-in-action.html