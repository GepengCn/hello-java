# Java 内存区域详解 JVM

## 问题

- 运行时数据区域概述
- 程序计数器
- Java 虚拟机栈
- 程序运行中栈可能会出现的错误
- 本地方法栈
- 堆
- 堆可能出现的错误
- 方法区
- 方法区和永久代以及元空间是什么关系呢？
- 为什么要将永久代替换为元空间呢?
- 方法区常用参数有哪些？
- 运行时常量池
- 字符串常量池
- JDK 1.7 为什么要将字符串常量池移动到堆中？
- 直接内存
- Java 对象的创建过程
- 内存分配的两种方式
- 内存分配并发问题
- 对象的内存布局
- 对象的访问定位
- 内存分配和回收原则
- 主要进行 gc 的区域
- 空间分配担保
- 死亡对象判断方法
- 哪些对象可以作为 GC Roots 呢？
- 对象可以被回收，就代表一定会被回收吗？
- 引用类型有哪些
- 如何判断一个常量是废弃常量？
- 如何判断一个类是无用的类？
- 垃圾收集算法有哪些？
- 垃圾收集器有哪些？
- 类的生命周期
- 类加载器介绍
- 双亲委派模型介绍
- 双亲委派模型的执行流程
- 双亲委派模型的好处
- 打破双亲委派模型方法
- 显式指定堆内存
- 显式新生代内存
- 显式指定永久代/元空间的大小
- 指定垃圾回收垃圾器
- GC 日志记录
- 处理 OOM 配置
- JDK 命令行工具描述一下
- 查看所有 Java 进程
- 监视虚拟机各种运行状态信息
- 实时地查看和调整虚拟机各项参数
- 生成堆转储快照
- 分析 heapdump 文件
- 生成虚拟机当前时刻的线程快照
- JVM线上问题排查和性能调优案例


## 答案
### 运行时数据区域概述

!!! tip "运行时数据区域概述"

    jdk1.8之前

    - 线程共享：堆、方法区、运行时常量池
    - 线程私有：虚拟机栈、本地方法栈、程序计数器
    - 本地内存：直接内存

    jdk1.8及之后

    - 线程共享：堆
    - 线程私有：虚拟机栈、本地方法栈、程序计数器
    - 本地内存：直接内存、元空间（方法区、运行时常量池）


### 程序计数器

!!! tip "程序计数器"

    可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

    另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。



### Java 虚拟机栈

!!! tip "Java 虚拟机栈"

    也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。

    除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现的

    方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。

    栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。

    - **局部变量表**:主要存放了编译期可知的各种数据类型、对象引用
    - **操作数栈**:主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。
    - **动态链接**:主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 **动态连接** 。
    - **方法返回地**:一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， **栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。**


### 程序运行中栈可能会出现的错误

!!! tip "程序运行中栈可能会出现的错误"

    - StackOverFlowError： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

    - OutOfMemoryError： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

### 本地方法栈

!!! tip "本地方法栈"

    和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。


### 堆

!!! tip "堆"

    Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

    堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。


    JDK8之前：新生代内存、老年代、永久代

    JDK8之后：PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。

    大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。


### 堆可能出现的错误

!!! tip "堆可能出现的错误"

    - `java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`:当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
    - `java.lang.OutOfMemoryError: Java heap space`:假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值)

### 方法区

!!! tip "方法区"

    当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。


### 方法区和永久代以及元空间是什么关系呢？

!!! tip "方法区和永久代以及元空间是什么关系呢？"

    方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。

    并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。


### 为什么要将永久代替换为元空间呢?

!!! tip "为什么要将永久代替换为元空间呢?"

    整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

### 方法区常用参数有哪些？

!!! tip "方法区常用参数有哪些？"

    JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。

    ```java
    -XX:PermSize=N //方法区 (永久代) 初始大小
    -XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
    ```
    相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

    JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。下面是一些常用参数：

    ```java
    -XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
    -XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
    ```

与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

### 运行时常量池

!!! tip "运行时常量池"

    用于存放编译期生成的各种字面量和符号引用的**常量池表**。

    运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。

    既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。

### 字符串常量池

!!! tip "字符串常量池"

    字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

    JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。

### JDK 1.7 为什么要将字符串常量池移动到堆中？

!!! tip "JDK 1.7 为什么要将字符串常量池移动到堆中？"

    主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

### 直接内存

!!! tip "直接内存"

    不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。

    并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。

    JDK1.4 中新加入的 NIO，引入了一种基于通道与缓存区的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

    直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

### Java 对象的创建过程

!!! tip "Java 对象的创建过程"

    - [x] 步骤1: 类加载检查

        ```虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。```

    - [x] 步骤2: 分配内存

        ```在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。```

    - [x] 步骤3: 初始化零值


        ```内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。```


    - [x] 步骤4: 设置对象头


        ```初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。```


    - [x] 步骤5: 执行 init 方法


        ```在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。```


### 内存分配的两种方式

!!! tip "内存分配的两种方式"

    - 指针碰撞：
        - 适用场合：堆内存规整（即没有内存碎片）的情况下。
        - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
        - 使用该分配方式的 GC 收集器：Serial, ParNew
    - 空闲列表：
        - 适用场合：堆内存不规整的情况下。
        - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
        - 使用该分配方式的 GC 收集器：CMS

    选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。


### 内存分配并发问题

!!! tip "内存分配并发问题"

    - CAS+失败重试
    - TLAB:为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

### 对象的内存布局

!!! tip "对象的内存布局"

    在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。

    Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

    实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。

    对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。#


### 对象的访问定位

!!! tip "对象的访问定位"

    目前主流的访问方式有：使用句柄、直接指针。

    - [x] 句柄

        Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

    - [x] 直接指针

        如果使用直接指针访问，reference 中存储的直接就是对象的地址。

    HotSpot 虚拟机主要使用的就是**指针**方式来进行对象访问。

### 内存分配和回收原则

!!! tip "内存分配和回收原则"

    - [x] 对象优先在 Eden 区分配

    大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC

    - [x] 大对象直接进入老年代

    大对象就是需要大量连续内存空间的对象。

    大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

    - [x] 长期存活的对象将进入老年代

    大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。

    对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。


    - [x] 主要进行 gc 的区域

    针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

    部分收集 (Partial GC)：

        - 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
        - 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
        - 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

    整堆收集 (Full GC)：收集整个 Java 堆和方法区。


    - [x] 空间分配担保

    空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。担保成功minor GC， 否则Full GC

### 死亡对象判断方法

!!! tip "死亡对象判断方法"

    - [x] 引用计数法

    但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。

    - [x] 可达性分析算法

    这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

### 哪些对象可以作为 GC Roots 呢？

!!! tip "哪些对象可以作为 GC Roots 呢？"

    - 虚拟机栈(栈帧中的本地变量表)中引用的对象
    - 本地方法栈(Native 方法)中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 所有被同步锁持有的对象

### 对象可以被回收，就代表一定会被回收吗？

!!! tip "对象可以被回收，就代表一定会被回收吗？"

    - 要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

    - 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。


### 引用类型有哪些

!!! tip "引用类型有哪些"

    - [x] 强引用

    垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

    - [x] 软引用

    如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存
    - [x] 弱引用

    弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

    - [x] 虚引用

    与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

    **虚引用主要用来跟踪对象被垃圾回收的活动。**

### 如何判断一个常量是废弃常量？

!!! tip "如何判断一个常量是废弃常量？"

    假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

### 如何判断一个类是无用的类？

!!! tip "如何判断一个类是无用的类？"

    - 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
    - 加载该类的 ClassLoader 已经被回收。
    - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法有哪些？

!!! tip "垃圾收集算法有哪些？"

    - [x] 标记-清除算法

    首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

    - 效率问题：标记和清除两个过程效率都不高。
    - 空间问题：标记清除后会产生大量不连续的内存碎片。

    - [x] 复制算法

    它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。

    - 可用内存变小：可用内存缩小为原来的一半。
    - 不适合老年代：如果存活对象数量比较大，复制性能会变得很差。
    
    - [x] 标记-整理算法

    标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

    由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。


    - [x] 分代收集算法

    根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代

    比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。

    而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。


### 垃圾收集器有哪些？

!!! tip "垃圾收集器有哪些？"

- [x] Serial 收集器

一个单线程收集器,进行垃圾收集工作的时候必须暂停其他所有的工作线程

新生代采用标记-复制算法，老年代采用标记-整理算法。

Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。


- [x] ParNew 收集器

其实就是 Serial 收集器的多线程版本


- [x] Parallel Scavenge 收集器

Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。

- [x] Serial Old 收集器

Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

- [x] Parallel Old 收集器

Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

- [x] CMS 收集器

一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。

HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

是一种 “标记-清除”算法实现的

整个过程分为四个步骤：
    - **初始标记**:暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
    - **并发标记**:
    - **重新标记**:
    - **并发清除**:

- [x] G1 收集器
- [x] ZGC 收集器

